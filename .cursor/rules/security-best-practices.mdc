---
globs: *.py,*.js,*.ts,*.tsx,*.jsx,*.json,*.yaml,*.yml,*.env*,Dockerfile*
description: Security best practices and guidelines
---

# Security Best Practices

## General Security Principles

- **Defense in Depth**: Implement multiple layers of security
- **Least Privilege**: Grant minimum necessary permissions
- **Fail Secure**: Default to secure state on failure
- **Input Validation**: Validate all user inputs
- **Output Encoding**: Encode outputs to prevent injection

## Authentication and Authorization

### Authentication
- Use strong password policies (min 12 chars, complexity requirements)
- Implement multi-factor authentication (TOTP, WebAuthn/FIDO2)
- Use secure session management (HttpOnly, Secure, SameSite cookies)
- Implement proper logout functionality (invalidate tokens/sessions)
- Use OAuth 2.0/OIDC for third-party authentication
- Implement rate limiting on authentication endpoints
- Use bcrypt, argon2, or scrypt for password hashing
- Implement account lockout after failed attempts
- Use secure password reset flows with time-limited tokens

### Authorization
- Implement role-based access control (RBAC) or attribute-based (ABAC)
- Use principle of least privilege
- Validate permissions on every request (don't trust client)
- Implement proper access controls at all layers
- Use JWT tokens securely (short expiry, secure storage, validate signature)
- Implement token refresh mechanisms
- Use opaque tokens for sensitive operations
- Verify token issuer and audience claims
- Implement proper scope validation

## Data Protection

### Sensitive Data
- Never store passwords in plain text
- Use strong encryption for sensitive data
- Implement proper key management
- Use environment variables for secrets
- Never commit secrets to version control

### Data Validation
- Validate all inputs on both client and server
- Use whitelist validation where possible
- Sanitize data before processing
- Implement proper error handling
- Use parameterized queries for databases

## API Security

### REST API Security
- Use HTTPS for all API communications (TLS 1.3+)
- Implement proper CORS policies (specific origins, not *)
- Use rate limiting to prevent abuse (per-user, per-IP)
- Validate all request parameters (type, format, range)
- Implement proper error handling (don't leak sensitive info)
- Use API keys or OAuth tokens for authentication
- Implement request signing for critical operations
- Use Content-Type validation
- Implement CSRF protection for state-changing operations
- Use security headers (X-Content-Type-Options, X-Frame-Options, etc.)

### GraphQL Security
- Implement query depth limiting
- Use query complexity analysis
- Validate all inputs
- Implement proper authorization
- Use introspection carefully

## Web Application Security

### Frontend Security
- Use Content Security Policy (CSP)
- Implement proper XSS protection
- Use secure cookies with proper flags
- Validate all client-side inputs
- Use HTTPS for all communications

### Backend Security
- Implement proper input validation
- Use prepared statements for database queries
- Implement proper error handling
- Use secure headers
- Implement proper logging and monitoring

## Infrastructure Security

### Container Security
- Use minimal base images (alpine, distroless)
- Run containers as non-root users (USER directive)
- Keep base images updated with security patches
- Use multi-stage builds to minimize attack surface
- Implement proper secrets management (Docker secrets, vault)
- Scan images for vulnerabilities (Trivy, Snyk, Clair)
- Limit container capabilities and use read-only filesystems
- Implement resource limits (CPU, memory)
- Use container security contexts and AppArmor/SELinux profiles

### Cloud Security
- Use IAM roles and policies
- Implement proper network segmentation
- Use encryption in transit and at rest
- Implement proper monitoring
- Use infrastructure as code

## Development Security

### Code Security
- Use secure coding practices
- Implement proper error handling
- Use static analysis tools
- Implement proper logging
- Use dependency scanning

### Dependency Management
- Keep dependencies updated regularly
- Use dependency scanning tools (Dependabot, Renovate, Snyk)
- Implement proper version pinning with ranges
- Monitor for security vulnerabilities (CVE databases)
- Use trusted package sources (PyPI, npm registry)
- Audit dependencies before adding (check maintainership, activity)
- Use lock files for reproducible builds
- Remove unused dependencies
- Consider supply chain security (SBOM, signed packages)

## Monitoring and Incident Response

### Security Monitoring
- Implement proper logging
- Use security monitoring tools
- Implement alerting for security events
- Monitor for unusual activity
- Implement proper audit trails

### Incident Response
- Have incident response procedures
- Implement proper backup and recovery
- Use security incident tracking
- Implement proper communication plans
- Conduct regular security reviews

## Compliance and Standards

### Security Standards
- Follow OWASP guidelines
- Implement security best practices
- Use industry-standard protocols
- Implement proper documentation
- Conduct regular security assessments

### Privacy Compliance
- Implement data protection measures
- Use proper consent mechanisms
- Implement data retention policies
- Use privacy by design principles
- Implement proper data handling procedures