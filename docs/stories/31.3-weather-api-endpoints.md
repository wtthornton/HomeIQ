# Story 31.3: Weather API Endpoints & Query Support

## Status

Draft

## Story

**As a** dashboard developer,
**I want** RESTful API endpoints to query current weather, forecasts, and historical weather data,
**so that** the health dashboard and analytics queries can access weather information independently without coupling to the event processing pipeline.

## Acceptance Criteria

1. GET /current-weather endpoint returns cached weather with <100ms response time
2. GET /forecast endpoint returns 24-hour weather forecast  
3. GET /historical endpoint supports time-range queries against InfluxDB
4. All endpoints return JSON responses with proper HTTP status codes
5. Endpoints include proper error handling (404, 500, 503)
6. GET /cache/stats endpoint returns cache hit rate and statistics
7. API responses include metadata (timestamp, source, location)
8. Endpoints support CORS for dashboard access (localhost:3000)
9. OpenAPI documentation auto-generated via FastAPI
10. Response models use Pydantic for validation

## Tasks / Subtasks

- [ ] Task 1: Implement Current Weather Endpoint (AC: 1, 4, 5, 7)
  - [ ] Create Pydantic response model for CurrentWeather
  - [ ] Implement GET /current-weather endpoint
  - [ ] Query cache service for most recent data
  - [ ] Return HTTP 200 with weather data if available
  - [ ] Return HTTP 503 if no data available (service starting)
  - [ ] Include timestamp, source, location in response
  - [ ] Add error handling for cache failures
  - [ ] Write unit tests for endpoint

- [ ] Task 2: Implement Forecast Endpoint (AC: 2, 4, 5, 7)
  - [ ] Create Pydantic response model for WeatherForecast
  - [ ] Implement GET /forecast endpoint with optional hours parameter
  - [ ] Integrate with OpenWeatherMap 5-day forecast API
  - [ ] Cache forecast data for 1 hour (separate cache key)
  - [ ] Return hourly forecast for next 24 hours (default)
  - [ ] Support ?hours=N query parameter (1-48 hours)
  - [ ] Include forecast timestamp and confidence in response
  - [ ] Write unit tests for forecast endpoint

- [ ] Task 3: Implement Historical Query Endpoint (AC: 3, 4, 5, 7)
  - [ ] Create Pydantic response model for HistoricalWeather
  - [ ] Implement GET /historical endpoint
  - [ ] Add query parameters: start_time, end_time, location
  - [ ] Query InfluxDB weather_data measurement
  - [ ] Support time-range queries (last 7 days default)
  - [ ] Return paginated results (limit 1000 records max)
  - [ ] Add aggregation support (hourly, daily averages)
  - [ ] Write unit tests for historical queries

- [ ] Task 4: Implement Cache Statistics Endpoint (AC: 6)
  - [ ] Create Pydantic response model for CacheStats
  - [ ] Implement GET /cache/stats endpoint
  - [ ] Return cache hit rate, miss rate, total requests
  - [ ] Include cache size and memory usage
  - [ ] Show cache TTL and last update time
  - [ ] Add cache entries count
  - [ ] Write unit tests for stats endpoint

- [ ] Task 5: Pydantic Response Models (AC: 10)
  - [ ] Define CurrentWeatherResponse model (temp, humidity, pressure, condition)
  - [ ] Define WeatherForecastResponse model (hourly forecast list)
  - [ ] Define HistoricalWeatherResponse model (paginated results)
  - [ ] Define CacheStatsResponse model (hit/miss rates, size)
  - [ ] Add field validators for temperature ranges, humidity 0-100%
  - [ ] Include example values for OpenAPI docs
  - [ ] Add docstrings for all fields

- [ ] Task 6: Error Handling & HTTP Status Codes (AC: 5)
  - [ ] Handle cache miss gracefully (trigger fetch, return 503 if unavailable)
  - [ ] Return 404 for invalid location in historical queries
  - [ ] Return 500 for internal errors (InfluxDB connection failures)
  - [ ] Return 503 when weather API is unavailable
  - [ ] Return 400 for invalid query parameters
  - [ ] Include error message and error_code in error responses
  - [ ] Log all errors with correlation IDs

- [ ] Task 7: OpenAPI Documentation (AC: 9)
  - [ ] Add endpoint descriptions and summaries
  - [ ] Add example requests and responses
  - [ ] Document query parameters with types and defaults
  - [ ] Add tags for endpoint grouping (Weather, Cache, Historical)
  - [ ] Include authentication info (none required for now)
  - [ ] Verify OpenAPI schema at /docs
  - [ ] Test ReDoc UI at /redoc

- [ ] Task 8: Integration Testing (AC: 1-10)
  - [ ] Write integration tests for all endpoints
  - [ ] Test current weather with cache hit and miss
  - [ ] Test forecast with different hours parameters
  - [ ] Test historical queries with various time ranges
  - [ ] Test cache stats endpoint
  - [ ] Test error scenarios (no data, invalid params)
  - [ ] Test CORS headers for dashboard access
  - [ ] Verify OpenAPI schema generation

## Dev Notes

### Testing Standards

**API Testing Pattern:**
```python
from fastapi.testclient import TestClient

def test_current_weather_cached(client: TestClient, mock_cache):
    # Arrange: Cache has data
    mock_cache.get.return_value = {"temperature": 72, "humidity": 45}
    
    # Act: Request current weather
    response = client.get("/current-weather")
    
    # Assert: 200 with data
    assert response.status_code == 200
    data = response.json()
    assert data["temperature"] == 72
    assert "timestamp" in data
```

**Test Coverage Requirements:**
- All endpoints (current, forecast, historical, stats)
- Success scenarios (200 status codes)
- Error scenarios (400, 404, 500, 503)
- Cache hit/miss behavior
- Query parameter validation
- Response model validation
- CORS headers

### Architecture Context

**Pydantic Response Models** (Context7 Verified):

```python
from pydantic import BaseModel, Field
from datetime import datetime
from typing import Optional, List

class CurrentWeatherResponse(BaseModel):
    """Current weather conditions"""
    temperature: float = Field(..., description="Temperature in Celsius", ge=-50, le=60)
    feels_like: float = Field(..., description="Feels like temperature in Celsius")
    humidity: int = Field(..., description="Humidity percentage", ge=0, le=100)
    pressure: int = Field(..., description="Atmospheric pressure in hPa")
    condition: str = Field(..., description="Weather condition (Clear, Clouds, Rain, etc.)")
    wind_speed: float = Field(..., description="Wind speed in m/s")
    cloudiness: int = Field(..., description="Cloudiness percentage", ge=0, le=100)
    visibility: Optional[int] = Field(None, description="Visibility in meters")
    timestamp: datetime = Field(..., description="Data timestamp (UTC)")
    location: str = Field(..., description="Location name")
    source: str = Field(default="openweathermap", description="Data source")
    
    class Config:
        json_schema_extra = {
            "example": {
                "temperature": 22.5,
                "feels_like": 21.0,
                "humidity": 45,
                "pressure": 1013,
                "condition": "Clear",
                "wind_speed": 3.5,
                "cloudiness": 10,
                "visibility": 10000,
                "timestamp": "2025-10-19T14:30:00Z",
                "location": "Las Vegas",
                "source": "openweathermap"
            }
        }

class ForecastHour(BaseModel):
    """Single hour forecast"""
    time: datetime = Field(..., description="Forecast time (UTC)")
    temperature: float = Field(..., description="Predicted temperature in Celsius")
    condition: str = Field(..., description="Predicted weather condition")
    precipitation_chance: int = Field(..., description="Chance of precipitation (%)", ge=0, le=100)

class WeatherForecastResponse(BaseModel):
    """24-hour weather forecast"""
    location: str
    forecast: List[ForecastHour]
    generated_at: datetime
    source: str = "openweathermap"

class HistoricalWeatherResponse(BaseModel):
    """Historical weather query results"""
    location: str
    start_time: datetime
    end_time: datetime
    records: List[CurrentWeatherResponse]
    total_records: int
    page: int = 1
    page_size: int = 100

class CacheStatsResponse(BaseModel):
    """Cache performance statistics"""
    hit_count: int
    miss_count: int
    hit_rate: float = Field(..., description="Hit rate percentage", ge=0, le=100)
    total_entries: int
    memory_usage_mb: float
    ttl_seconds: int
    last_update: Optional[datetime]
```

**Endpoint Implementation Patterns:**

```python
@app.get("/current-weather", response_model=CurrentWeatherResponse, tags=["Weather"])
async def get_current_weather(location: str = Query("Las Vegas")) -> CurrentWeatherResponse:
    """
    Get current weather conditions for a location.
    
    Returns cached data if available (15-minute TTL), otherwise triggers a fetch.
    """
    # Check cache first
    cached = cache.get(f"weather:{location}")
    if cached:
        return CurrentWeatherResponse(**cached)
    
    # Cache miss - trigger fetch (async, non-blocking)
    weather_data = await weather_client.get_current_weather(location)
    
    if not weather_data:
        raise HTTPException(
            status_code=503,
            detail="Weather data currently unavailable"
        )
    
    # Update cache
    cache.set(f"weather:{location}", weather_data)
    
    return CurrentWeatherResponse(**weather_data)

@app.get("/forecast", response_model=WeatherForecastResponse, tags=["Weather"])
async def get_forecast(
    location: str = Query("Las Vegas"),
    hours: int = Query(24, ge=1, le=48, description="Forecast hours (1-48)")
) -> WeatherForecastResponse:
    """Get hourly weather forecast for the next N hours."""
    # Check forecast cache (1-hour TTL)
    cache_key = f"forecast:{location}:{hours}"
    cached = cache.get(cache_key)
    if cached:
        return WeatherForecastResponse(**cached)
    
    # Fetch forecast from OpenWeatherMap
    forecast_data = await weather_client.get_forecast(location, hours)
    
    if not forecast_data:
        raise HTTPException(status_code=503, detail="Forecast unavailable")
    
    # Cache for 1 hour
    cache.set(cache_key, forecast_data, ttl=3600)
    
    return WeatherForecastResponse(**forecast_data)

@app.get("/historical", response_model=HistoricalWeatherResponse, tags=["Historical"])
async def get_historical_weather(
    location: str = Query("Las Vegas"),
    start_time: datetime = Query(..., description="Start time (UTC)"),
    end_time: datetime = Query(..., description="End time (UTC)"),
    page: int = Query(1, ge=1),
    page_size: int = Query(100, ge=1, le=1000)
) -> HistoricalWeatherResponse:
    """Query historical weather data from InfluxDB."""
    # Query InfluxDB
    records = await influxdb_query.query_weather_history(
        location=location,
        start=start_time,
        end=end_time,
        limit=page_size,
        offset=(page - 1) * page_size
    )
    
    if not records:
        raise HTTPException(status_code=404, detail="No weather data found")
    
    return HistoricalWeatherResponse(
        location=location,
        start_time=start_time,
        end_time=end_time,
        records=records,
        total_records=len(records),
        page=page,
        page_size=page_size
    )

@app.get("/cache/stats", response_model=CacheStatsResponse, tags=["Cache"])
async def get_cache_stats() -> CacheStatsResponse:
    """Get cache performance statistics."""
    stats = cache.get_stats()
    
    return CacheStatsResponse(
        hit_count=stats['hits'],
        miss_count=stats['misses'],
        hit_rate=(stats['hits'] / (stats['hits'] + stats['misses']) * 100) if (stats['hits'] + stats['misses']) > 0 else 0,
        total_entries=len(cache.cache),
        memory_usage_mb=sys.getsizeof(cache.cache) / 1024 / 1024,
        ttl_seconds=cache.ttl,
        last_update=cache.last_update
    )
```

### Reference Implementations

**Sports Data Historical Endpoints** (`services/sports-data/src/main.py`):
- Similar pattern for historical queries ✅
- Pagination support (page, page_size) ✅
- Time-range filtering ✅
- Cache for query results ✅

**Air Quality Current Endpoint** (`services/air-quality-service/src/main.py`):
- Similar /current-aqi endpoint pattern ✅
- Cache-first strategy ✅
- Error handling (503 when unavailable) ✅

### Context7 Verification

**FastAPI Response Models** (verified against `/fastapi/fastapi`):
- ✅ Pydantic `BaseModel` for request/response validation
- ✅ `Field` with descriptions and constraints
- ✅ `json_schema_extra` for OpenAPI examples
- ✅ `response_model` parameter in route decorators
- ✅ Automatic OpenAPI schema generation

**Query Parameters** (verified against `/fastapi/fastapi`):
- ✅ `Query` with default values and validation
- ✅ Type hints for automatic conversion
- ✅ `ge` (greater than or equal) constraints
- ✅ `description` for API documentation

### Critical Success Factors

1. **Response Time**: <100ms for cached current weather
2. **Cache Hit Rate**: >80% (reduce API calls)
3. **Error Handling**: Clear error messages for all failure modes
4. **OpenAPI Docs**: Complete documentation at /docs
5. **CORS Support**: Dashboard can call endpoints without errors

### Integration Points

**Dependencies:**
- Story 31.2 (Weather Data Collection) - MUST BE COMPLETE
- Cache service with weather data populated
- InfluxDB with weather_data measurement

**Will Enable:**
- Story 31.5 (Dashboard Integration) - Dashboard will call these endpoints

### Performance Targets

- GET /current-weather: <100ms (cached), <2s (fresh fetch)
- GET /forecast: <200ms (cached), <3s (API call)
- GET /historical: <500ms (InfluxDB query)
- GET /cache/stats: <10ms
- Concurrent requests: Support 100 req/s

### API Documentation Examples

**OpenAPI Tags:**
```python
tags_metadata = [
    {
        "name": "Weather",
        "description": "Current weather and forecast endpoints",
    },
    {
        "name": "Historical",
        "description": "Historical weather data queries",
    },
    {
        "name": "Cache",
        "description": "Cache performance and statistics",
    },
]

app = FastAPI(
    title="Weather API Service",
    description="Weather data integration for Home Assistant analytics",
    version="1.0.0",
    openapi_tags=tags_metadata
)
```

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-19 | 1.0 | Initial story creation | BMad Master |

## Dev Agent Record

*This section will be populated during implementation*

### Agent Model Used

*To be filled by dev agent*

### Debug Log References

*To be filled by dev agent*

### Completion Notes

*To be filled by dev agent*

### File List

*To be filled by dev agent*

## QA Results

*Results from QA Agent review will be added here*

