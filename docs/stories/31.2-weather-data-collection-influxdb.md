# Story 31.2: Weather Data Collection & InfluxDB Persistence

## Status

Draft

## Story

**As a** system administrator,
**I want** weather data continuously collected from OpenWeatherMap and persisted to InfluxDB with intelligent caching,
**so that** weather information is always available for correlation queries without excessive API calls or performance issues.

## Acceptance Criteria

1. OpenWeatherMap client migrated from websocket-ingestion to weather-api service
2. Weather data fetching implemented with 15-minute cache TTL
3. Weather data written to InfluxDB `weather_data` measurement (NOT home_assistant_events)
4. Continuous background fetch loop runs every 5 minutes (4x per cache TTL)
5. Cache service tracks hit/miss statistics and expiration times
6. Weather client handles API failures gracefully with fallback to cached data
7. InfluxDB writes include proper tags (location, condition) and fields (temp, humidity, pressure)
8. Circuit breaker pattern prevents excessive API calls on repeated failures
9. Weather data includes timestamp, source, and location metadata
10. Service maintains <100MB memory footprint with caching

## Tasks / Subtasks

- [ ] Task 1: Migrate OpenWeatherMap Client (AC: 1, 6)
  - [ ] Copy `services/websocket-ingestion/src/weather_client.py` to `services/weather-api/src/`
  - [ ] Refactor OpenWeatherMapClient class to remove event enrichment logic
  - [ ] Add async context manager support (`async with` pattern)
  - [ ] Implement retry logic with exponential backoff
  - [ ] Add comprehensive error handling and logging
  - [ ] Update to use aiohttp ClientSession from lifespan

- [ ] Task 2: Implement Caching Layer (AC: 2, 5, 10)
  - [ ] Create `src/cache_service.py` module
  - [ ] Implement CacheService class with TTL support (15 minutes default)
  - [ ] Add cache entry expiration tracking
  - [ ] Track cache hit/miss statistics
  - [ ] Implement cache invalidation logic
  - [ ] Add memory-efficient storage (max 100 cache entries)
  - [ ] Provide cache statistics API

- [ ] Task 3: Implement Circuit Breaker Pattern (AC: 6, 8)
  - [ ] Create `src/circuit_breaker.py` module
  - [ ] Implement CircuitBreaker class (copy from sports-data service)
  - [ ] Configure failure threshold (3 failures → open circuit)
  - [ ] Configure timeout (60 seconds before retry)
  - [ ] Add circuit state tracking (closed, open, half-open)
  - [ ] Integrate circuit breaker with weather client
  - [ ] Log circuit breaker state changes

- [ ] Task 4: InfluxDB Integration (AC: 3, 7, 9)
  - [ ] Create `src/influxdb_writer.py` module
  - [ ] Implement InfluxDBWriter class using InfluxDB3 Python client
  - [ ] Configure Point creation with proper tags and fields
  - [ ] Tags: location, condition, source
  - [ ] Fields: temperature, humidity, pressure, wind_speed, cloudiness
  - [ ] Add batch writing support (write every 5 minutes)
  - [ ] Handle InfluxDB connection failures gracefully
  - [ ] Add InfluxDB write statistics tracking

- [ ] Task 5: Continuous Background Fetch Loop (AC: 4)
  - [ ] Create `src/weather_scheduler.py` module
  - [ ] Implement continuous fetch loop with asyncio.sleep(300) # 5 minutes
  - [ ] Integrate with OpenWeatherMap client and cache
  - [ ] Check cache before fetching (cache-first strategy)
  - [ ] Update cache on successful fetch
  - [ ] Write to InfluxDB after cache update
  - [ ] Handle exceptions without crashing loop
  - [ ] Add graceful shutdown support

- [ ] Task 6: Lifespan Integration (AC: 1, 4)
  - [ ] Update `src/main.py` lifespan manager
  - [ ] Initialize aiohttp ClientSession for weather client
  - [ ] Initialize InfluxDB client connection
  - [ ] Start continuous fetch loop as background task
  - [ ] Add proper shutdown sequence (cancel tasks, close connections)
  - [ ] Track initialization errors in health check

- [ ] Task 7: Testing & Validation (AC: 1-10)
  - [ ] Write unit tests for OpenWeatherMap client
  - [ ] Write unit tests for cache service (hit/miss, expiration)
  - [ ] Write unit tests for circuit breaker (state transitions)
  - [ ] Write unit tests for InfluxDB writer
  - [ ] Write integration tests for full fetch-cache-write flow
  - [ ] Mock OpenWeatherMap API responses for testing
  - [ ] Mock InfluxDB writes for testing
  - [ ] Test cache memory footprint (<100MB target)
  - [ ] Test circuit breaker failure scenarios

- [ ] Task 8: Monitoring & Observability (AC: 5, 8)
  - [ ] Add Prometheus metrics for cache hit rate
  - [ ] Add metrics for API call success/failure counts
  - [ ] Add metrics for InfluxDB write success/failure
  - [ ] Add circuit breaker state to health check
  - [ ] Update `/health` endpoint with component status
  - [ ] Log cache statistics every 15 minutes

## Dev Notes

### Testing Standards

**Test File Structure:**
```
tests/
├── test_weather_client.py        # OpenWeatherMap client tests
├── test_cache_service.py          # Cache layer tests
├── test_circuit_breaker.py        # Circuit breaker tests
├── test_influxdb_writer.py        # InfluxDB integration tests
├── test_weather_scheduler.py      # Background loop tests
└── integration/
    └── test_fetch_write_flow.py   # End-to-end tests
```

**Key Test Scenarios:**
- Cache hit (data within 15-min TTL)
- Cache miss (data expired or not present)
- Cache expiration (TTL exceeded)
- API failure with fallback to cache
- Circuit breaker opens after 3 failures
- Circuit breaker closes after successful retry
- InfluxDB write success and failure
- Background loop continues after errors
- Memory footprint under load

### Architecture Context

**InfluxDB Schema** (Context7 Verified):

```python
# Write weather data to InfluxDB using Point class
from influxdb_client_3 import Point

point = Point("weather") \
    .tag("location", location_name) \
    .tag("condition", weather_condition) \
    .tag("source", "openweathermap") \
    .field("temperature", float(temp_celsius)) \
    .field("humidity", float(humidity_percent)) \
    .field("pressure", float(pressure_hpa)) \
    .field("wind_speed", float(wind_mps)) \
    .field("cloudiness", float(cloud_percent)) \
    .time(timestamp)

client.write(point)
```

**Cache Service Pattern:**

```python
class CacheService:
    """In-memory cache with TTL support"""
    
    def __init__(self, ttl_seconds: int = 900):  # 15 minutes
        self.cache: Dict[str, CacheEntry] = {}
        self.ttl = ttl_seconds
        self.hits = 0
        self.misses = 0
    
    def get(self, key: str) -> Optional[Any]:
        if key in self.cache:
            entry = self.cache[key]
            if datetime.now() < entry.expires_at:
                self.hits += 1
                return entry.data
            else:
                del self.cache[key]  # Expired
        
        self.misses += 1
        return None
    
    def set(self, key: str, data: Any):
        self.cache[key] = CacheEntry(
            data=data,
            expires_at=datetime.now() + timedelta(seconds=self.ttl)
        )
```

**Circuit Breaker Pattern:**

```python
class CircuitBreaker:
    """Circuit breaker to prevent cascading failures"""
    
    def __init__(self, failure_threshold: int = 3, timeout_seconds: int = 60):
        self.failure_threshold = failure_threshold
        self.timeout = timeout_seconds
        self.failure_count = 0
        self.state = "closed"  # closed, open, half-open
        self.last_failure_time = None
    
    def call(self, func: Callable):
        if self.state == "open":
            if self._should_attempt_reset():
                self.state = "half-open"
            else:
                raise CircuitBreakerOpen("Circuit breaker is open")
        
        try:
            result = func()
            self._on_success()
            return result
        except Exception as e:
            self._on_failure()
            raise e
    
    def _on_success(self):
        self.failure_count = 0
        self.state = "closed"
    
    def _on_failure(self):
        self.failure_count += 1
        self.last_failure_time = datetime.now()
        
        if self.failure_count >= self.failure_threshold:
            self.state = "open"
```

**Continuous Fetch Loop:**

```python
async def run_continuous_fetch(self):
    """Background task to fetch weather every 5 minutes"""
    logger.info("Starting continuous weather fetch loop...")
    
    while True:
        try:
            # Check cache first (15-min TTL)
            cached = self.cache.get("current_weather")
            if cached:
                logger.debug("Using cached weather data")
                await asyncio.sleep(300)  # 5 minutes
                continue
            
            # Fetch from OpenWeatherMap
            weather_data = await self.weather_client.get_current_weather(location)
            
            if weather_data:
                # Update cache
                self.cache.set("current_weather", weather_data)
                
                # Write to InfluxDB
                await self.influxdb_writer.write_weather(weather_data)
                
                logger.info(f"Weather updated: {weather_data['temperature']}°C, {weather_data['condition']}")
            
            # Sleep 5 minutes before next fetch
            await asyncio.sleep(300)
            
        except Exception as e:
            logger.error(f"Error in fetch loop: {e}")
            await asyncio.sleep(60)  # Retry in 1 minute on error
```

### Reference Implementations

**Similar Services to Follow:**

1. **Carbon Intensity Service** (`services/carbon-intensity-service/src/main.py`):
   - Continuous background fetch loop ✅
   - External API integration with retry ✅
   - InfluxDB Point writer ✅
   - Cache with fallback ✅

2. **Air Quality Service** (`services/air-quality-service/src/main.py`):
   - Similar fetch-cache-write pattern ✅
   - Health check with component status ✅
   - Continuous monitoring loop ✅

3. **Sports Data Service** (`services/sports-data/src/cache_service.py`):
   - Cache implementation with TTL ✅
   - Circuit breaker pattern ✅
   - Cache statistics tracking ✅

### Context7 Verification

**InfluxDB3 Python Client** (verified against `/influxcommunity/influxdb3-python`):
- ✅ Point class for structured data writing
- ✅ Tag/field separation (tags for indexing, fields for values)
- ✅ Timestamp precision handling
- ✅ Batch writing support
- ✅ Error handling for write failures

**FastAPI Lifespan** (verified against `/fastapi/fastapi`):
- ✅ `@asynccontextmanager` for resource lifecycle
- ✅ `yield` for startup/shutdown separation
- ✅ Background task management
- ✅ Graceful shutdown with `asyncio.Task.cancel()`

### Critical Success Factors

1. **Cache Efficiency**: Hit rate must exceed 80% to reduce API calls
2. **Circuit Breaker**: Must prevent cascading failures to OpenWeatherMap
3. **Memory Management**: Cache must stay under 100MB
4. **InfluxDB Writes**: Must be non-blocking (fire-and-forget pattern)
5. **Background Loop**: Must survive exceptions without crashing service

### Integration Points

**Dependencies:**
- Story 31.1 (Service Foundation) - MUST BE COMPLETE
- InfluxDB (weather_data bucket must exist)
- OpenWeatherMap API (valid API key required)

**Will Enable:**
- Story 31.3 (API Endpoints) - Will query cached data
- Story 31.5 (Dashboard Integration) - Will display weather data

### Performance Targets

- OpenWeatherMap API calls: <100 per day (vs ~1,440 with event enrichment)
- Cache hit rate: >80%
- InfluxDB write latency: <50ms (async)
- Memory footprint: <100MB
- Background loop CPU: <5%

### Environment Variables Required

```bash
# OpenWeatherMap API
WEATHER_API_KEY=your_openweathermap_api_key
WEATHER_LOCATION=Las Vegas  # Default location

# Cache Configuration
CACHE_TTL_SECONDS=900  # 15 minutes
FETCH_INTERVAL_SECONDS=300  # 5 minutes

# Circuit Breaker
CIRCUIT_BREAKER_FAILURE_THRESHOLD=3
CIRCUIT_BREAKER_TIMEOUT_SECONDS=60

# InfluxDB (from shared config)
INFLUXDB_URL=http://influxdb:8086
INFLUXDB_TOKEN=<token>
INFLUXDB_ORG=home_assistant
INFLUXDB_BUCKET=weather_data
```

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-19 | 1.0 | Initial story creation | BMad Master |

## Dev Agent Record

*This section will be populated during implementation*

### Agent Model Used

*To be filled by dev agent*

### Debug Log References

*To be filled by dev agent*

### Completion Notes

*To be filled by dev agent*

### File List

*To be filled by dev agent*

## QA Results

*Results from QA Agent review will be added here*

