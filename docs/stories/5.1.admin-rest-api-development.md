# Story 5.1: Admin REST API Development

## Status

Ready for Development

## Story

**As a** system administrator,  
**I want** a REST API for admin operations,  
**so that** I can monitor system health and manage configuration through a web interface.

## Acceptance Criteria

1. REST API provides endpoints for system health monitoring (`/api/health`)
2. API includes statistics endpoints for event processing metrics (`/api/stats`)
3. Configuration management endpoints allow viewing and updating system settings (`/api/config`)
4. Recent events endpoint provides filtered access to captured data (`/api/events/recent`)
5. All endpoints return structured JSON responses with proper error handling
6. API includes request validation and authentication for sensitive operations
7. API documentation is available through OpenAPI/Swagger specification

## Tasks / Subtasks

- [ ] Task 1: Implement core REST API framework (AC: 5, 7)
  - [ ] Create FastAPI application with async support
  - [ ] Implement OpenAPI/Swagger documentation generation
  - [ ] Add structured JSON response formatting
  - [ ] Implement comprehensive error handling and validation
  - [ ] Add API versioning and routing structure

- [ ] Task 2: Implement system health monitoring endpoints (AC: 1)
  - [ ] Create `/api/health` endpoint with comprehensive health checks
  - [ ] Implement service status aggregation and reporting
  - [ ] Add dependency health checking (database, APIs, services)
  - [ ] Implement health check caching and performance optimization
  - [ ] Add health metrics and trend analysis

- [ ] Task 3: Implement statistics and metrics endpoints (AC: 2)
  - [ ] Create `/api/stats` endpoint for event processing metrics
  - [ ] Implement real-time statistics calculation and aggregation
  - [ ] Add historical metrics and trend analysis
  - [ ] Implement performance metrics and throughput statistics
  - [ ] Add custom metrics and KPI reporting

- [ ] Task 4: Implement configuration management endpoints (AC: 3)
  - [ ] Create `/api/config` endpoints for configuration management
  - [ ] Implement configuration viewing with sensitive data masking
  - [ ] Add configuration update and validation
  - [ ] Implement configuration backup and restore capabilities
  - [ ] Add configuration change tracking and audit logging

- [ ] Task 5: Implement recent events access endpoints (AC: 4)
  - [ ] Create `/api/events/recent` endpoint for event data access
  - [ ] Implement event filtering and querying capabilities
  - [ ] Add pagination and result limiting
  - [ ] Implement event data formatting and normalization
  - [ ] Add event search and filtering options

- [ ] Task 6: Implement request validation and authentication (AC: 6)
  - [ ] Create request validation and schema checking
  - [ ] Implement API authentication and authorization
  - [ ] Add rate limiting and request throttling
  - [ ] Implement input sanitization and security validation
  - [ ] Add audit logging and request tracking

- [ ] Task 7: Implement comprehensive API documentation (AC: 7)
  - [ ] Create OpenAPI 3.0 specification for all endpoints
  - [ ] Implement interactive Swagger UI documentation
  - [ ] Add API usage examples and code samples
  - [ ] Implement API testing and validation tools
  - [ ] Add API changelog and versioning documentation

- [ ] Task 8: Create comprehensive tests (AC: All)
  - [ ] Create `test_api_endpoints.py` for endpoint testing
  - [ ] Create `test_health_endpoints.py` for health check testing
  - [ ] Create `test_stats_endpoints.py` for statistics testing
  - [ ] Create `test_config_endpoints.py` for configuration testing
  - [ ] Create `test_events_endpoints.py` for events testing
  - [ ] Add integration tests for complete API workflow

## Dev Notes

### Previous Story Insights
[Source: Story 4.3 completion notes]
- Production deployment and orchestration system is established
- Docker Compose configuration and service management are implemented
- Resource limits and graceful shutdown procedures are available
- Deployment documentation and automation are operational

### Technology Stack
[Source: architecture/tech-stack.md]

**Admin REST API Technology:**
- **Backend Framework:** FastAPI for modern async REST API development
- **Backend Language:** Python 3.11 for API implementation
- **API Documentation:** OpenAPI 3.0 with automatic Swagger UI generation
- **Authentication:** FastAPI security and OAuth2 integration
- **Testing:** pytest 7.4+ for API testing

### API Specification Requirements
[Source: architecture/data-models.md]

**OpenAPI 3.0 Specification:**
```yaml
openapi: 3.0.0
info:
  title: Home Assistant Ingestion Layer API
  version: 1.0.0
  description: Admin API for monitoring and managing the Home Assistant ingestion system
servers:
  - url: http://localhost:8080/api
    description: Local development server
paths:
  /health:
    get:
      summary: Get system health status
      responses:
        '200':
          description: System health information
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/SystemHealth'
  
  /stats:
    get:
      summary: Get system statistics
      responses:
        '200':
          description: System statistics
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/EventStats'
  
  /events/recent:
    get:
      summary: Get recent events
      parameters:
        - name: limit
          in: query
          schema:
            type: integer
            default: 100
          description: Number of events to return
        - name: entity_id
          in: query
          schema:
            type: string
          description: Filter by entity ID
      responses:
        '200':
          description: List of recent events
          content:
            application/json:
              schema:
                type: array
                items:
                  $ref: '#/components/schemas/HomeAssistantEvent'
  
  /config:
    get:
      summary: Get system configuration
      responses:
        '200':
          description: System configuration
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Configuration'
    put:
      summary: Update system configuration
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/ConfigurationUpdate'
      responses:
        '200':
          description: Configuration updated successfully
        '400':
          description: Invalid configuration
```

### API Data Models
[Source: architecture/data-models.md]

**System Health Model:**
```typescript
interface SystemHealth {
  service_status: ServiceStatus;
  event_stats: EventStats;
  connection_status: ConnectionStatus;
  last_updated: string;
}

interface ServiceStatus {
  websocket_client: 'healthy' | 'unhealthy';
  enrichment_service: 'healthy' | 'unhealthy';
  influxdb: 'healthy' | 'unhealthy';
  weather_api: 'healthy' | 'unhealthy';
}

interface EventStats {
  events_per_hour: number;
  total_events_today: number;
  last_event_time?: string;
  error_rate: number;
}
```

**Configuration Model:**
```typescript
interface Configuration {
  ha_url: string;
  ha_token_masked: string; // Shows only last 4 characters
  weather_api_key_masked: string; // Shows only last 4 characters
  weather_location: string;
  retention_days: number;
  weather_cache_minutes: number;
}
```

### Configuration Requirements
[Source: architecture/development-workflow.md]

**Required Environment Variables:**
```bash
# Admin API Configuration
ADMIN_API_HOST=0.0.0.0
ADMIN_API_PORT=8080
ADMIN_API_WORKERS=4

# API Security Configuration
API_AUTHENTICATION_ENABLED=false  # For development
API_RATE_LIMIT_PER_MINUTE=1000
API_REQUEST_TIMEOUT_SECONDS=30

# API Documentation Configuration
API_DOCS_ENABLED=true
API_DOCS_TITLE=Home Assistant Ingestion API
API_DOCS_VERSION=1.0.0

# Logging Configuration
LOG_LEVEL=INFO
LOG_FORMAT=json
```

### File Locations
[Source: architecture/unified-project-structure.md]

**Admin API Service Structure:**
```
services/admin-api/
├── src/
│   ├── __init__.py
│   ├── main.py                # FastAPI application entry point
│   ├── routes/
│   │   ├── __init__.py
│   │   ├── health.py          # Health endpoints
│   │   ├── stats.py           # Statistics endpoints
│   │   ├── events.py          # Events endpoints
│   │   └── config.py          # Configuration endpoints
│   ├── models/
│   │   ├── __init__.py
│   │   ├── events.py          # Event data models
│   │   ├── health.py          # Health data models
│   │   └── config.py          # Configuration data models
│   ├── services/
│   │   ├── __init__.py
│   │   ├── health_service.py  # Health check service
│   │   ├── stats_service.py   # Statistics service
│   │   ├── events_service.py  # Events service
│   │   └── config_service.py  # Configuration service
│   └── utils/
│       ├── __init__.py
│       ├── auth.py            # Authentication utilities
│       ├── validation.py      # Request validation
│       └── errors.py          # Error handling
├── tests/
│   ├── test_api_endpoints.py
│   ├── test_health_endpoints.py
│   ├── test_stats_endpoints.py
│   ├── test_config_endpoints.py
│   └── test_events_endpoints.py
├── Dockerfile
└── requirements.txt
```

### API Endpoint Implementation
[Source: architecture/data-models.md]

**FastAPI Application Setup with Context7 Patterns:**
```python
from fastapi import FastAPI, HTTPException, Depends, status
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
from fastapi.openapi.docs import get_swagger_ui_html
from fastapi.openapi.utils import get_openapi
from pydantic import BaseModel, Field, validator
from typing import Optional, List, Dict, Any
import asyncio
import logging
from datetime import datetime, timedelta

# Pydantic Models for Request/Response Validation
class SystemHealth(BaseModel):
    service_status: Dict[str, str] = Field(..., description="Status of each service")
    event_stats: Dict[str, Any] = Field(..., description="Event processing statistics")
    connection_status: Dict[str, Any] = Field(..., description="Connection health status")
    last_updated: datetime = Field(..., description="Last update timestamp")

class EventStats(BaseModel):
    events_per_hour: int = Field(..., ge=0, description="Events processed per hour")
    total_events_today: int = Field(..., ge=0, description="Total events today")
    last_event_time: Optional[datetime] = Field(None, description="Last event timestamp")
    error_rate: float = Field(..., ge=0, le=1, description="Error rate (0-1)")

class ConfigurationUpdate(BaseModel):
    weather_location: Optional[str] = Field(None, min_length=1, max_length=100)
    retention_days: Optional[int] = Field(None, ge=1, le=365)
    weather_cache_minutes: Optional[int] = Field(None, ge=1, le=1440)
    
    @validator('weather_location')
    def validate_location(cls, v):
        if v and not v.replace(' ', '').replace('-', '').isalpha():
            raise ValueError('Location must contain only letters, spaces, and hyphens')
        return v

class EventQuery(BaseModel):
    limit: int = Field(100, ge=1, le=1000, description="Number of events to return")
    entity_id: Optional[str] = Field(None, description="Filter by entity ID")
    start_time: Optional[datetime] = Field(None, description="Start time filter")
    end_time: Optional[datetime] = Field(None, description="End time filter")
    
    @validator('end_time')
    def validate_time_range(cls, v, values):
        if v and 'start_time' in values and values['start_time']:
            if v <= values['start_time']:
                raise ValueError('End time must be after start time')
        return v

# FastAPI Application Configuration
app = FastAPI(
    title="Home Assistant Ingestion API",
    version="1.0.0",
    description="Admin API for monitoring and managing the Home Assistant ingestion system",
    docs_url="/api/docs",
    redoc_url="/api/redoc",
    openapi_url="/api/openapi.json"
)

# CORS Middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # Configure appropriately for production
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Dependency Injection
async def get_health_service():
    return HealthService()

async def get_stats_service():
    return StatsService()

async def get_config_service():
    return ConfigService()

async def get_events_service():
    return EventsService()

# Health Endpoint Implementation
@app.get("/api/health", response_model=SystemHealth)
async def get_system_health(
    health_service: HealthService = Depends(get_health_service)
):
    """Get comprehensive system health status"""
    try:
        health_status = await health_service.get_system_health()
        return SystemHealth(**health_status)
    except Exception as e:
        logging.error(f"Health check failed: {e}")
        raise HTTPException(
            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
            detail=f"Health check failed: {str(e)}"
        )

# Statistics Endpoint Implementation
@app.get("/api/stats", response_model=EventStats)
async def get_system_stats(
    stats_service: StatsService = Depends(get_stats_service)
):
    """Get system statistics and metrics"""
    try:
        stats = await stats_service.get_system_stats()
        return EventStats(**stats)
    except Exception as e:
        logging.error(f"Stats retrieval failed: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Stats retrieval failed: {str(e)}"
        )

# Configuration Endpoints
@app.get("/api/config")
async def get_configuration(
    config_service: ConfigService = Depends(get_config_service)
):
    """Get current system configuration"""
    try:
        config = await config_service.get_configuration()
        return config
    except Exception as e:
        logging.error(f"Configuration retrieval failed: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Configuration retrieval failed: {str(e)}"
        )

@app.put("/api/config")
async def update_configuration(
    config_update: ConfigurationUpdate,
    config_service: ConfigService = Depends(get_config_service)
):
    """Update system configuration"""
    try:
        updated_config = await config_service.update_configuration(config_update.dict(exclude_unset=True))
        return {"message": "Configuration updated successfully", "config": updated_config}
    except ValueError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"Invalid configuration: {str(e)}"
        )
    except Exception as e:
        logging.error(f"Configuration update failed: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Configuration update failed: {str(e)}"
        )

# Events Endpoint Implementation
@app.get("/api/events/recent")
async def get_recent_events(
    query: EventQuery = Depends(),
    events_service: EventsService = Depends(get_events_service)
):
    """Get recent events with filtering and pagination"""
    try:
        events = await events_service.get_recent_events(
            limit=query.limit,
            entity_id=query.entity_id,
            start_time=query.start_time,
            end_time=query.end_time
        )
        return {
            "events": events,
            "count": len(events),
            "query": query.dict(exclude_unset=True)
        }
    except Exception as e:
        logging.error(f"Events retrieval failed: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Events retrieval failed: {str(e)}"
        )

# Custom OpenAPI Schema
def custom_openapi():
    if app.openapi_schema:
        return app.openapi_schema
    openapi_schema = get_openapi(
        title="Home Assistant Ingestion API",
        version="1.0.0",
        description="Admin API for monitoring and managing the Home Assistant ingestion system",
        routes=app.routes,
    )
    # Add custom tags
    openapi_schema["tags"] = [
        {"name": "health", "description": "System health monitoring"},
        {"name": "stats", "description": "System statistics and metrics"},
        {"name": "config", "description": "Configuration management"},
        {"name": "events", "description": "Event data access"},
    ]
    app.openapi_schema = openapi_schema
    return app.openapi_schema

app.openapi = custom_openapi

# Global Exception Handler
@app.exception_handler(Exception)
async def global_exception_handler(request, exc):
    logging.error(f"Unhandled exception: {exc}")
    return JSONResponse(
        status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
        content={"detail": "Internal server error", "error": str(exc)}
    )

# Startup and Shutdown Events
@app.on_event("startup")
async def startup_event():
    logging.info("Home Assistant Ingestion API starting up")
    # Initialize services, connections, etc.

@app.on_event("shutdown")
async def shutdown_event():
    logging.info("Home Assistant Ingestion API shutting down")
    # Cleanup resources, close connections, etc.
```

**Request Validation and Error Handling:**
```python
from fastapi import Request, HTTPException
from fastapi.responses import JSONResponse
from fastapi.exceptions import RequestValidationError
from pydantic import ValidationError
import logging

@app.exception_handler(RequestValidationError)
async def validation_exception_handler(request: Request, exc: RequestValidationError):
    """Handle Pydantic validation errors"""
    return JSONResponse(
        status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
        content={
            "detail": "Validation error",
            "errors": exc.errors(),
            "body": exc.body
        }
    )

@app.exception_handler(ValidationError)
async def pydantic_validation_exception_handler(request: Request, exc: ValidationError):
    """Handle Pydantic model validation errors"""
    return JSONResponse(
        status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
        content={
            "detail": "Model validation error",
            "errors": exc.errors()
        }
    )
```

**Rate Limiting Implementation:**
```python
from slowapi import Limiter, _rate_limit_exceeded_handler
from slowapi.util import get_remote_address
from slowapi.errors import RateLimitExceeded

limiter = Limiter(key_func=get_remote_address)
app.state.limiter = limiter
app.add_exception_handler(RateLimitExceeded, _rate_limit_exceeded_handler)

@app.get("/api/stats")
@limiter.limit("100/minute")
async def get_system_stats(request: Request, stats_service: StatsService = Depends(get_stats_service)):
    """Get system statistics with rate limiting"""
    # Implementation here
    pass
```

### Testing Requirements
[Source: architecture/testing-strategy.md]

**API Test Organization:**
```
services/admin-api/tests/
├── test_api_endpoints.py
├── test_health_endpoints.py
├── test_stats_endpoints.py
├── test_config_endpoints.py
├── test_events_endpoints.py
└── test_api_integration.py
```

**Test Examples:**
```python
import pytest
import httpx
from fastapi.testclient import TestClient
from services.admin_api.src.main import app

@pytest.fixture
def client():
    return TestClient(app)

def test_health_endpoint(client):
    """Test health endpoint returns valid health status"""
    response = client.get("/api/health")
    
    assert response.status_code == 200
    data = response.json()
    
    assert "service_status" in data
    assert "event_stats" in data
    assert "connection_status" in data
    assert "last_updated" in data

def test_stats_endpoint(client):
    """Test stats endpoint returns valid statistics"""
    response = client.get("/api/stats")
    
    assert response.status_code == 200
    data = response.json()
    
    assert "events_per_hour" in data
    assert "total_events_today" in data
    assert "error_rate" in data

def test_events_recent_endpoint(client):
    """Test recent events endpoint with filtering"""
    response = client.get("/api/events/recent?limit=50&entity_id=sensor.temperature")
    
    assert response.status_code == 200
    data = response.json()
    
    assert isinstance(data, list)
    assert len(data) <= 50
```

### Coding Standards
[Source: architecture/coding-standards.md]

**Critical Rules:**
- **API Design:** All endpoints must follow RESTful conventions
- **Error Handling:** All API errors must return structured JSON responses
- **Validation:** All requests must be validated before processing
- **Naming Conventions:** 
  - Endpoints: kebab-case (e.g., `/api/events/recent`)
  - Functions: snake_case (e.g., `get_system_health()`)
  - Models: PascalCase (e.g., `SystemHealth`)

### Performance Considerations
[Source: architecture/security-and-performance.md]

**API Performance:**
- Async endpoints for non-blocking operations
- Response caching for frequently accessed data
- Request validation and rate limiting
- Efficient database queries and data aggregation
- Configurable request timeouts and worker processes

### Security Implementation
[Source: architecture/security-and-performance.md]

**API Security:**
- Request validation and input sanitization
- Rate limiting and request throttling
- Authentication and authorization (configurable)
- Sensitive data masking in responses
- Audit logging and request tracking

### API Documentation Features
[Source: architecture/data-models.md]

**OpenAPI Documentation:**
- Interactive Swagger UI for API exploration
- Comprehensive endpoint documentation with examples
- Request/response schema validation
- API versioning and changelog
- Code generation for client SDKs

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2024-12-19 | 1.0 | Initial story creation from Epic 5.1 | Scrum Master Bob |

## Dev Agent Record

*This section will be populated by the development agent during implementation*

### Agent Model Used

*To be filled by dev agent*

### Debug Log References

*To be filled by dev agent*

### Completion Notes List

*To be filled by dev agent*

### File List

*To be filled by dev agent*

## QA Results

*Results from QA Agent review will be populated here*
