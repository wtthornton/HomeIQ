# Story 1.9: Testing and Quality Assurance

## Story Overview

**As a** system administrator,  
**I want** comprehensive testing and quality assurance,  
**so that** the enhanced dashboard is reliable and bug-free.

## Acceptance Criteria

1. Comprehensive test suite covers all new functionality
2. Integration tests verify existing functionality remains intact
3. Visual regression tests ensure UI consistency
4. Accessibility tests verify WCAG compliance
5. User acceptance testing validates all requirements

## Integration Verification

**IV1**: All existing tests continue to pass  
**IV2**: New tests cover integration points with existing code  
**IV3**: Test coverage meets or exceeds current project standards

## Technical Requirements

### Playwright Configuration
- Set up Playwright with proper configuration for visual testing:
  ```tsx
  // playwright.config.ts
  import { defineConfig, devices } from '@playwright/test';
  
  export default defineConfig({
    testDir: './tests/e2e',
    fullyParallel: true,
    forbidOnly: !!process.env.CI,
    retries: process.env.CI ? 2 : 0,
    workers: process.env.CI ? 1 : undefined,
    reporter: 'html',
    use: {
      baseURL: 'http://localhost:3000',
      trace: 'on-first-retry',
      screenshot: 'only-on-failure',
    },
    projects: [
      {
        name: 'chromium',
        use: { ...devices['Desktop Chrome'] },
      },
      {
        name: 'firefox',
        use: { ...devices['Desktop Firefox'] },
      },
      {
        name: 'webkit',
        use: { ...devices['Desktop Safari'] },
      },
      {
        name: 'Mobile Chrome',
        use: { ...devices['Pixel 5'] },
      },
      {
        name: 'Mobile Safari',
        use: { ...devices['iPhone 12'] },
      },
    ],
    webServer: {
      command: 'npm run dev',
      url: 'http://localhost:3000',
      reuseExistingServer: !process.env.CI,
    },
  });
  ```
- Add Playwright utilities for common testing patterns:
  ```tsx
  // tests/utils/playwright-helpers.ts
  export class DashboardTestHelpers {
    static async waitForDashboardLoad(page: Page) {
      await page.waitForLoadState('networkidle');
      await page.waitForSelector('[data-testid="health-cards"]');
      await page.waitForSelector('[data-testid="metrics-chart"]');
    }
    
    static async takeComponentScreenshot(page: Page, selector: string, name: string) {
      await expect(page.locator(selector)).toHaveScreenshot(`${name}.png`);
    }
    
    static async testResponsiveLayout(page: Page, viewport: { width: number; height: number }) {
      await page.setViewportSize(viewport);
      await this.waitForDashboardLoad(page);
      await expect(page).toHaveScreenshot(`dashboard-${viewport.width}x${viewport.height}.png`);
    }
  }
  ```

### Test Suite Enhancement
- Extend existing Vitest test suite with new component tests
- Implement comprehensive unit tests using React Testing Library:
  ```tsx
  import { render, screen, fireEvent, waitFor } from '@testing-library/react';
  import { vi } from 'vitest';
  
  const renderWithProviders = (ui: React.ReactElement, options = {}) => {
    const AllTheProviders = ({ children }: { children: React.ReactNode }) => {
      return (
        <NotificationProvider>
          <ThemeProvider>
            {children}
          </ThemeProvider>
        </NotificationProvider>
      );
    };
    
    return render(ui, { wrapper: AllTheProviders, ...options });
  };
  
  const mockWebSocket = () => {
    const mockWS = {
      send: vi.fn(),
      close: vi.fn(),
      addEventListener: vi.fn(),
      removeEventListener: vi.fn(),
    };
    vi.stubGlobal('WebSocket', vi.fn(() => mockWS));
    return mockWS;
  };
  ```
- Add integration tests for new features
- Ensure test coverage meets project standards (80%+)

### Regression Testing
- Implement Playwright visual testing with screenshots and accessibility snapshots:
  ```tsx
  import { test, expect } from '@playwright/test';
  
  test.describe('Dashboard Visual Tests', () => {
    test('dashboard layout matches snapshot', async ({ page }) => {
      await page.goto('/dashboard');
      await page.waitForLoadState('networkidle');
      
      // Full page screenshot
      await expect(page).toHaveScreenshot('dashboard-full-page.png');
      
      // Component-specific screenshots
      await expect(page.locator('[data-testid="health-cards"]')).toHaveScreenshot('health-cards.png');
      await expect(page.locator('[data-testid="metrics-chart"]')).toHaveScreenshot('metrics-chart.png');
    });
    
    test('mobile layout matches snapshot', async ({ page }) => {
      await page.setViewportSize({ width: 375, height: 667 });
      await page.goto('/dashboard');
      await expect(page).toHaveScreenshot('dashboard-mobile.png');
    });
    
    test('dark theme matches snapshot', async ({ page }) => {
      await page.goto('/dashboard');
      await page.click('[data-testid="theme-toggle"]');
      await expect(page).toHaveScreenshot('dashboard-dark-theme.png');
    });
  });
  ```
- Add accessibility snapshot testing:
  ```tsx
  test('dashboard accessibility tree matches snapshot', async ({ page }) => {
    await page.goto('/dashboard');
    await expect(page.locator('body')).toMatchAriaSnapshot(`
      - banner:
        - heading /Health Dashboard/ [level=1]
        - button "Theme Toggle"
      - main:
        - region "Health Status"
        - region "Metrics Chart"
        - region "Event Feed"
    `);
  });
  ```
- Create regression tests for existing functionality
- Implement automated testing for critical user flows
- Ensure existing features continue to work after changes

### Accessibility Testing
- Implement Playwright accessibility testing with violation fingerprinting:
  ```tsx
  test('dashboard accessibility compliance', async ({ page }) => {
    await page.goto('/dashboard');
    
    // Run accessibility scan
    const accessibilityScanResults = await page.accessibility.snapshot();
    
    // Test for specific violations (stable approach)
    const violationFingerprints = accessibilityScanResults.violations.map(violation => ({
      rule: violation.id,
      targets: violation.nodes.map(node => node.target),
    }));
    
    expect(violationFingerprints).toMatchSnapshot('accessibility-violations.json');
    
    // Test specific accessibility properties
    await expect(page.getByRole('heading', { name: /Health Dashboard/ })).toBeVisible();
    await expect(page.getByRole('button', { name: /Theme Toggle/ })).toBeVisible();
    await expect(page.getByRole('main')).toBeVisible();
  });
  ```
- Add manual accessibility testing procedures
- Ensure WCAG 2.1 AA compliance
- Test with screen readers and keyboard navigation

### Performance Testing
- Add Playwright performance testing with metrics collection:
  ```tsx
  test('dashboard performance metrics', async ({ page }) => {
    await page.goto('/dashboard');
    
    // Collect performance metrics
    const metrics = await page.evaluate(() => {
      const navigation = performance.getEntriesByType('navigation')[0] as PerformanceNavigationTiming;
      return {
        loadTime: navigation.loadEventEnd - navigation.loadEventStart,
        domContentLoaded: navigation.domContentLoadedEventEnd - navigation.domContentLoadedEventStart,
        firstPaint: performance.getEntriesByName('first-paint')[0]?.startTime,
        firstContentfulPaint: performance.getEntriesByName('first-contentful-paint')[0]?.startTime,
      };
    });
    
    // Assert performance thresholds
    expect(metrics.loadTime).toBeLessThan(3000); // 3 seconds
    expect(metrics.firstContentfulPaint).toBeLessThan(1500); // 1.5 seconds
  });
  ```
- Implement load testing for dashboard components
- Add WebSocket connection performance testing:
  ```tsx
  test('WebSocket connection performance', async ({ page }) => {
    const connectionTimes: number[] = [];
    
    page.on('websocket', ws => {
      const startTime = Date.now();
      ws.on('open', () => {
        connectionTimes.push(Date.now() - startTime);
      });
    });
    
    await page.goto('/dashboard');
    await page.waitForLoadState('networkidle');
    
    expect(connectionTimes[0]).toBeLessThan(1000); // 1 second
  });
  ```
- Ensure performance meets established benchmarks
- Test with various data volumes and update frequencies

### Test Data Management
- Implement Playwright API mocking for consistent test data:
  ```tsx
  test('dashboard with mocked data', async ({ page }) => {
    // Mock API responses
    await page.route('**/api/health', route => {
      route.fulfill({
        status: 200,
        contentType: 'application/json',
        body: JSON.stringify({
          status: 'healthy',
          services: [
            { name: 'WebSocket Service', status: 'running', uptime: '99.9%' },
            { name: 'Database', status: 'running', uptime: '99.8%' }
          ]
        })
      });
    });
    
    await page.route('**/api/metrics', route => {
      route.fulfill({
        status: 200,
        contentType: 'application/json',
        body: JSON.stringify({
          eventsPerSecond: 45,
          totalEvents: 125000,
          averageLatency: 12
        })
      });
    });
    
    await page.goto('/dashboard');
    await DashboardTestHelpers.waitForDashboardLoad(page);
    
    // Verify mocked data is displayed
    await expect(page.getByText('99.9%')).toBeVisible();
    await expect(page.getByText('45 events/sec')).toBeVisible();
  });
  ```
- Add WebSocket message mocking:
  ```tsx
  test('real-time updates with mocked WebSocket', async ({ page }) => {
    await page.goto('/dashboard');
    
    // Mock WebSocket messages
    await page.addInitScript(() => {
      const originalWebSocket = window.WebSocket;
      window.WebSocket = class extends originalWebSocket {
        constructor(url: string) {
          super(url);
          setTimeout(() => {
            this.dispatchEvent(new MessageEvent('message', {
              data: JSON.stringify({
                type: 'health_update',
                data: { status: 'warning', message: 'High CPU usage detected' }
              })
            }));
          }, 1000);
        }
      };
    });
    
    await page.waitForSelector('[data-testid="notification-warning"]');
    await expect(page.getByText('High CPU usage detected')).toBeVisible();
  });
  ```

### User Acceptance Testing
- Create UAT test cases for all new features
- Implement user testing procedures
- Validate all acceptance criteria
- Ensure user experience meets requirements

## Dependencies

- **Prerequisites**: All previous stories (1.1-1.8)
- **Blocks**: None (final story)
- **External**: Vitest, Testing Library, **Playwright**, accessibility testing tools

## Definition of Done

- [ ] Comprehensive test suite implemented
- [ ] Regression tests passing
- [ ] **Playwright visual regression tests working**
- [ ] **Screenshot comparisons passing across all browsers**
- [ ] **Accessibility snapshots validated**
- [ ] **Performance metrics within thresholds**
- [ ] **WebSocket connection tests passing**
- [ ] **API mocking tests working**
- [ ] User acceptance testing completed
- [ ] All existing tests still passing
- [ ] Test coverage targets met (80%+)
- [ ] Code reviewed and approved

## Implementation Notes

- Build on existing test infrastructure and patterns
- Implement tests incrementally with each story
- **Set up Playwright configuration for cross-browser testing**
- **Create reusable Playwright test utilities and helpers**
- **Implement visual regression testing for all UI components**
- **Add accessibility snapshot testing for compliance**
- **Use Playwright API mocking for consistent test data**
- **Test WebSocket connections and real-time updates**
- Ensure tests are maintainable and reliable
- Document testing procedures for future development

## Risk Mitigation

- Test each component individually before integration
- Implement comprehensive error handling in tests
- Ensure tests don't break existing functionality
- Use realistic test data and scenarios
- Maintain test performance and reliability
