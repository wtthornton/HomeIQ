# Story 1.2: Home Assistant WebSocket Authentication

## Status

Draft

## Story

**As a** system administrator,  
**I want** secure authentication with Home Assistant using long-lived access tokens,  
**so that** the ingestion service can establish reliable WebSocket connections.

## Acceptance Criteria

1. Long-lived access token is properly configured and validated
2. WebSocket connection is established successfully with Home Assistant
3. Authentication errors are logged with clear error messages
4. Connection retry logic handles authentication failures gracefully
5. Token validation occurs before attempting WebSocket connection
6. Authentication status is exposed through health check endpoint
7. Invalid or expired tokens result in clear error messages and service restart

## Tasks / Subtasks

- [ ] Task 1: Create WebSocket client service structure (AC: 2, 6)
  - [ ] Create `services/websocket-ingestion/` directory structure
  - [ ] Create `services/websocket-ingestion/src/` directory
  - [ ] Create `services/websocket-ingestion/src/__init__.py`
  - [ ] Create `services/websocket-ingestion/src/main.py` (service entry point)
  - [ ] Create `services/websocket-ingestion/src/websocket_client.py` (HA WebSocket client)
  - [ ] Create `services/websocket-ingestion/src/health_check.py` (health monitoring)
  - [ ] Create `services/websocket-ingestion/requirements.txt`
  - [ ] Create `services/websocket-ingestion/Dockerfile`

- [ ] Task 2: Implement token validation system (AC: 1, 5)
  - [ ] Create token validation function with format checking
  - [ ] Implement token format validation (length, character validation)
  - [ ] Add token expiration checking if applicable
  - [ ] Create token masking utility for logging (show only last 4 characters)
  - [ ] Implement token validation before WebSocket connection attempt

- [ ] Task 3: Implement WebSocket authentication (AC: 2, 3)
  - [ ] Create WebSocket client class using aiohttp
  - [ ] Implement authentication header with Bearer token
  - [ ] Add WebSocket connection establishment logic
  - [ ] Implement authentication error handling and logging
  - [ ] Add connection status tracking and reporting

- [ ] Task 4: Implement connection retry logic (AC: 4)
  - [ ] Create exponential backoff retry mechanism
  - [ ] Implement retry logic for authentication failures
  - [ ] Add retry logic for connection failures
  - [ ] Implement maximum retry attempts configuration
  - [ ] Add retry delay configuration with exponential backoff

- [ ] Task 5: Implement health check endpoint (AC: 6)
  - [ ] Create health check HTTP server using aiohttp
  - [ ] Implement `/health` endpoint for authentication status
  - [ ] Add connection status reporting in health response
  - [ ] Include authentication status in health check response
  - [ ] Add last connection attempt timestamp to health status

- [ ] Task 6: Implement comprehensive error handling (AC: 3, 7)
  - [ ] Create structured error logging system
  - [ ] Implement authentication error categorization
  - [ ] Add clear error messages for different failure types
  - [ ] Implement service restart logic for invalid tokens
  - [ ] Add error context and debugging information

- [ ] Task 7: Create configuration management (AC: 1)
  - [ ] Create configuration class for WebSocket settings
  - [ ] Implement environment variable loading
  - [ ] Add Home Assistant URL configuration
  - [ ] Add access token configuration with validation
  - [ ] Create configuration validation on startup

- [ ] Task 8: Create comprehensive tests (AC: All)
  - [ ] Create `services/websocket-ingestion/tests/` directory
  - [ ] Create `test_websocket_client.py` for WebSocket client testing
  - [ ] Create `test_token_validation.py` for token validation testing
  - [ ] Create `test_health_check.py` for health endpoint testing
  - [ ] Add integration tests for authentication flow
  - [ ] Add mock Home Assistant WebSocket server for testing

## Dev Notes

### Previous Story Insights
[Source: Story 1.1 completion notes]
- Docker infrastructure is established with proper networking
- Environment variables system is configured
- Health check endpoints are available for monitoring
- Logging infrastructure is set up with structured logging

### Technology Stack
[Source: architecture/tech-stack.md]

**WebSocket Client Technology:**
- **Backend Language:** Python 3.11 for WebSocket client and data processing
- **Backend Framework:** aiohttp 3.9+ for WebSocket client + REST API
- **Authentication:** Long-lived Access Tokens for Home Assistant authentication
- **Monitoring:** Python logging for application logging
- **Testing:** pytest 7.4+ for backend service testing

### Context7 Implementation Guidance

#### aiohttp WebSocket Client Implementation
[Source: Context7 Knowledge Base - aiohttp]

**Basic WebSocket Client Class:**
```python
# services/websocket-ingestion/src/websocket_client.py
import aiohttp
import asyncio
import json
import logging
from typing import Optional, Dict, Any
from datetime import datetime

logger = logging.getLogger(__name__)

class HomeAssistantWebSocketClient:
    def __init__(self, url: str, access_token: str):
        self.url = url
        self.access_token = access_token
        self.session: Optional[aiohttp.ClientSession] = None
        self.ws: Optional[aiohttp.ClientWebSocketResponse] = None
        self.connected = False
        self.authenticated = False
        self.reconnect_count = 0
        self.max_reconnect_attempts = 5
        self.reconnect_delay = 1  # Start with 1 second
        
    async def connect(self) -> bool:
        """Establish WebSocket connection with Home Assistant"""
        try:
            self.session = aiohttp.ClientSession()
            
            # Configure WebSocket connection with timeout
            timeout = aiohttp.ClientWSTimeout(ws_receive=30, ws_close=10)
            
            async with self.session.ws_connect(
                self.url,
                timeout=timeout,
                heartbeat=30,  # Send ping every 30 seconds
                autoping=True,
                autoclose=True
            ) as ws:
                self.ws = ws
                self.connected = True
                
                # Authenticate with Home Assistant
                if await self._authenticate():
                    logger.info("Successfully connected and authenticated to Home Assistant")
                    return True
                else:
                    logger.error("Authentication failed")
                    return False
                    
        except aiohttp.ClientError as e:
            logger.error(f"WebSocket connection error: {e}")
            return False
        except Exception as e:
            logger.error(f"Unexpected error during connection: {e}")
            return False
    
    async def _authenticate(self) -> bool:
        """Authenticate with Home Assistant WebSocket API"""
        try:
            # Wait for auth_required message
            auth_required = await self.ws.receive_json()
            logger.debug(f"Received auth_required: {auth_required}")
            
            if auth_required.get("type") != "auth_required":
                logger.error("Expected auth_required message")
                return False
            
            # Send authentication
            auth_msg = {
                "type": "auth",
                "access_token": self.access_token
            }
            await self.ws.send_json(auth_msg)
            
            # Wait for authentication response
            auth_response = await self.ws.receive_json()
            logger.debug(f"Received auth response: {auth_response}")
            
            if auth_response.get("type") == "auth_ok":
                self.authenticated = True
                logger.info("Authentication successful")
                return True
            elif auth_response.get("type") == "auth_invalid":
                logger.error(f"Authentication failed: {auth_response.get('message')}")
                return False
            else:
                logger.error(f"Unexpected auth response: {auth_response}")
                return False
                
        except Exception as e:
            logger.error(f"Authentication error: {e}")
            return False
    
    async def disconnect(self):
        """Disconnect from WebSocket"""
        if self.ws:
            await self.ws.close()
        if self.session:
            await self.session.close()
        self.connected = False
        self.authenticated = False
        logger.info("Disconnected from Home Assistant")
    
    async def send_ping(self) -> bool:
        """Send ping to check connection health"""
        try:
            if self.ws and self.connected:
                await self.ws.ping("health_check")
                return True
        except Exception as e:
            logger.error(f"Ping failed: {e}")
        return False
    
    def is_connected(self) -> bool:
        """Check if WebSocket is connected"""
        return self.connected and self.ws is not None
    
    def is_authenticated(self) -> bool:
        """Check if authenticated with Home Assistant"""
        return self.authenticated
```

#### Home Assistant WebSocket Authentication Flow
[Source: Context7 Knowledge Base - Home Assistant WebSocket API]

**Authentication Message Flow:**
```python
# Complete authentication flow implementation
async def authenticate_with_ha(ws: aiohttp.ClientWebSocketResponse, token: str) -> bool:
    """Complete Home Assistant authentication flow"""
    
    # 1. Receive auth_required
    auth_required = await ws.receive_json()
    # Expected: {"type": "auth_required", "ha_version": "2021.5.3"}
    
    # 2. Send authentication
    auth_msg = {
        "type": "auth",
        "access_token": token
    }
    await ws.send_json(auth_msg)
    
    # 3. Receive auth_ok or auth_invalid
    auth_response = await ws.receive_json()
    # Success: {"type": "auth_ok", "ha_version": "2021.5.3"}
    # Failure: {"type": "auth_invalid", "message": "Invalid password"}
    
    return auth_response.get("type") == "auth_ok"
```

**Token Validation Implementation:**
```python
# services/websocket-ingestion/src/token_validator.py
import re
from typing import Tuple, Optional

class TokenValidator:
    """Validates Home Assistant access tokens"""
    
    @staticmethod
    def validate_token_format(token: str) -> Tuple[bool, Optional[str]]:
        """Validate token format and return (is_valid, error_message)"""
        
        if not token:
            return False, "Token is empty"
        
        if len(token) < 20:
            return False, "Token too short (minimum 20 characters)"
        
        if len(token) > 200:
            return False, "Token too long (maximum 200 characters)"
        
        # Check for valid characters (alphanumeric, hyphens, underscores)
        if not re.match(r'^[a-zA-Z0-9_-]+$', token):
            return False, "Token contains invalid characters"
        
        return True, None
    
    @staticmethod
    def mask_token(token: str) -> str:
        """Mask token for logging (show only last 4 characters)"""
        if len(token) <= 4:
            return "****"
        return f"{'*' * (len(token) - 4)}{token[-4:]}"
    
    @staticmethod
    def validate_token_before_connection(token: str) -> bool:
        """Validate token before attempting WebSocket connection"""
        is_valid, error = TokenValidator.validate_token_format(token)
        if not is_valid:
            logger.error(f"Token validation failed: {error}")
            return False
        return True
```

#### Connection Retry Logic with Exponential Backoff
[Source: Context7 Knowledge Base - aiohttp]

**Retry Implementation:**
```python
# services/websocket-ingestion/src/connection_manager.py
import asyncio
import random
from typing import Callable, Any

class ConnectionManager:
    """Manages WebSocket connection with retry logic"""
    
    def __init__(self, max_retries: int = 5, base_delay: float = 1.0):
        self.max_retries = max_retries
        self.base_delay = base_delay
        self.retry_count = 0
    
    async def connect_with_retry(
        self, 
        connect_func: Callable[[], Any],
        on_success: Callable[[], None] = None,
        on_failure: Callable[[Exception], None] = None
    ) -> bool:
        """Connect with exponential backoff retry"""
        
        for attempt in range(self.max_retries):
            try:
                logger.info(f"Connection attempt {attempt + 1}/{self.max_retries}")
                
                result = await connect_func()
                if result:
                    self.retry_count = 0
                    if on_success:
                        on_success()
                    return True
                    
            except Exception as e:
                logger.error(f"Connection attempt {attempt + 1} failed: {e}")
                if on_failure:
                    on_failure(e)
                
                if attempt < self.max_retries - 1:
                    delay = self._calculate_delay(attempt)
                    logger.info(f"Retrying in {delay} seconds...")
                    await asyncio.sleep(delay)
        
        logger.error(f"Failed to connect after {self.max_retries} attempts")
        return False
    
    def _calculate_delay(self, attempt: int) -> float:
        """Calculate exponential backoff delay with jitter"""
        delay = self.base_delay * (2 ** attempt)
        jitter = random.uniform(0, delay * 0.1)  # Add 10% jitter
        return min(delay + jitter, 60)  # Cap at 60 seconds
```

#### Health Check Implementation
[Source: Context7 Knowledge Base - aiohttp]

**Health Check HTTP Server:**
```python
# services/websocket-ingestion/src/health_check.py
from aiohttp import web
import json
from datetime import datetime
from typing import Dict, Any

class HealthCheckServer:
    """HTTP server for health check endpoints"""
    
    def __init__(self, websocket_client):
        self.websocket_client = websocket_client
        self.app = web.Application()
        self._setup_routes()
    
    def _setup_routes(self):
        """Setup health check routes"""
        self.app.router.add_get('/health', self.health_check)
        self.app.router.add_get('/health/detailed', self.detailed_health_check)
    
    async def health_check(self, request: web.Request) -> web.Response:
        """Basic health check endpoint"""
        status = "healthy" if self.websocket_client.is_connected() else "unhealthy"
        
        response_data = {
            "status": status,
            "timestamp": datetime.utcnow().isoformat(),
            "service": "websocket-ingestion"
        }
        
        status_code = 200 if status == "healthy" else 503
        return web.json_response(response_data, status=status_code)
    
    async def detailed_health_check(self, request: web.Request) -> web.Response:
        """Detailed health check with connection status"""
        
        health_data = {
            "status": "healthy" if self.websocket_client.is_connected() else "unhealthy",
            "timestamp": datetime.utcnow().isoformat(),
            "service": "websocket-ingestion",
            "connection": {
                "connected": self.websocket_client.is_connected(),
                "authenticated": self.websocket_client.is_authenticated(),
                "reconnect_count": self.websocket_client.reconnect_count,
                "last_connection_attempt": getattr(self.websocket_client, 'last_connection_attempt', None)
            },
            "home_assistant": {
                "url": self.websocket_client.url,
                "token_masked": TokenValidator.mask_token(self.websocket_client.access_token)
            }
        }
        
        status_code = 200 if health_data["status"] == "healthy" else 503
        return web.json_response(health_data, status=status_code)

# Health check server startup
async def start_health_server(websocket_client, host='0.0.0.0', port=8080):
    """Start health check HTTP server"""
    health_server = HealthCheckServer(websocket_client)
    
    runner = web.AppRunner(health_server.app)
    await runner.setup()
    
    site = web.TCPSite(runner, host, port)
    await site.start()
    
    logger.info(f"Health check server started on {host}:{port}")
    return runner
```

#### Configuration Management
[Source: Context7 Knowledge Base - aiohttp]

**Configuration Class:**
```python
# services/websocket-ingestion/src/config.py
import os
from typing import Optional
from dataclasses import dataclass

@dataclass
class WebSocketConfig:
    """Configuration for WebSocket client"""
    
    ha_url: str
    ha_access_token: str
    log_level: str = "INFO"
    log_format: str = "json"
    max_reconnect_attempts: int = 5
    reconnect_delay: float = 1.0
    heartbeat_interval: int = 30
    health_check_port: int = 8080
    
    @classmethod
    def from_env(cls) -> 'WebSocketConfig':
        """Load configuration from environment variables"""
        
        ha_url = os.getenv('HA_URL')
        if not ha_url:
            raise ValueError("HA_URL environment variable is required")
        
        ha_access_token = os.getenv('HA_ACCESS_TOKEN')
        if not ha_access_token:
            raise ValueError("HA_ACCESS_TOKEN environment variable is required")
        
        return cls(
            ha_url=ha_url,
            ha_access_token=ha_access_token,
            log_level=os.getenv('LOG_LEVEL', 'INFO'),
            log_format=os.getenv('LOG_FORMAT', 'json'),
            max_reconnect_attempts=int(os.getenv('MAX_RECONNECT_ATTEMPTS', '5')),
            reconnect_delay=float(os.getenv('RECONNECT_DELAY', '1.0')),
            heartbeat_interval=int(os.getenv('HEARTBEAT_INTERVAL', '30')),
            health_check_port=int(os.getenv('HEALTH_CHECK_PORT', '8080'))
        )
    
    def validate(self) -> bool:
        """Validate configuration"""
        try:
            # Validate token format
            is_valid, error = TokenValidator.validate_token_format(self.ha_access_token)
            if not is_valid:
                logger.error(f"Token validation failed: {error}")
                return False
            
            # Validate URL format
            if not self.ha_url.startswith(('ws://', 'wss://')):
                logger.error("HA_URL must start with ws:// or wss://")
                return False
            
            return True
            
        except Exception as e:
            logger.error(f"Configuration validation error: {e}")
            return False
```

#### Error Handling and Logging
[Source: Context7 Knowledge Base - aiohttp]

**Structured Error Handling:**
```python
# services/websocket-ingestion/src/error_handler.py
import logging
import traceback
from typing import Dict, Any
from datetime import datetime

class ErrorHandler:
    """Centralized error handling for WebSocket client"""
    
    @staticmethod
    def log_authentication_error(error: Exception, token_masked: str) -> None:
        """Log authentication errors with context"""
        logger.error({
            "error_type": "authentication_failed",
            "error_message": str(error),
            "token_masked": token_masked,
            "timestamp": datetime.utcnow().isoformat(),
            "traceback": traceback.format_exc()
        })
    
    @staticmethod
    def log_connection_error(error: Exception, url: str, attempt: int) -> None:
        """Log connection errors with context"""
        logger.error({
            "error_type": "connection_failed",
            "error_message": str(error),
            "url": url,
            "attempt": attempt,
            "timestamp": datetime.utcnow().isoformat(),
            "traceback": traceback.format_exc()
        })
    
    @staticmethod
    def log_websocket_error(error: Exception, context: Dict[str, Any]) -> None:
        """Log WebSocket errors with context"""
        logger.error({
            "error_type": "websocket_error",
            "error_message": str(error),
            "context": context,
            "timestamp": datetime.utcnow().isoformat(),
            "traceback": traceback.format_exc()
        })
```

#### Testing Implementation
[Source: Context7 Knowledge Base - aiohttp]

**WebSocket Client Tests:**
```python
# services/websocket-ingestion/tests/test_websocket_client.py
import pytest
import asyncio
from unittest.mock import AsyncMock, patch
from services.websocket_ingestion.src.websocket_client import HomeAssistantWebSocketClient

@pytest.mark.asyncio
async def test_websocket_connection():
    """Test WebSocket connection establishment"""
    client = HomeAssistantWebSocketClient("ws://test-ha:8123/websocket", "test_token")
    
    with patch('aiohttp.ClientSession.ws_connect') as mock_connect:
        mock_ws = AsyncMock()
        mock_ws.receive_json.side_effect = [
            {"type": "auth_required", "ha_version": "2021.5.3"},
            {"type": "auth_ok", "ha_version": "2021.5.3"}
        ]
        mock_connect.return_value.__aenter__.return_value = mock_ws
        
        result = await client.connect()
        
        assert result is True
        assert client.is_connected() is True
        assert client.is_authenticated() is True

@pytest.mark.asyncio
async def test_authentication_failure():
    """Test authentication failure handling"""
    client = HomeAssistantWebSocketClient("ws://test-ha:8123/websocket", "invalid_token")
    
    with patch('aiohttp.ClientSession.ws_connect') as mock_connect:
        mock_ws = AsyncMock()
        mock_ws.receive_json.side_effect = [
            {"type": "auth_required", "ha_version": "2021.5.3"},
            {"type": "auth_invalid", "message": "Invalid password"}
        ]
        mock_connect.return_value.__aenter__.return_value = mock_ws
        
        result = await client.connect()
        
        assert result is False
        assert client.is_authenticated() is False

def test_token_validation():
    """Test token validation"""
    from services.websocket_ingestion.src.token_validator import TokenValidator
    
    # Valid token
    is_valid, error = TokenValidator.validate_token_format("valid_token_123")
    assert is_valid is True
    assert error is None
    
    # Invalid token (too short)
    is_valid, error = TokenValidator.validate_token_format("short")
    assert is_valid is False
    assert "too short" in error
    
    # Invalid token (invalid characters)
    is_valid, error = TokenValidator.validate_token_format("invalid@token!")
    assert is_valid is False
    assert "invalid characters" in error
```

### WebSocket Authentication Requirements
[Source: architecture/data-models.md#Home Assistant WebSocket API]

**Home Assistant WebSocket API Integration:**
- **Base URL:** `ws://homeassistant.local:8123/api/websocket` (or custom HA URL)
- **Authentication:** Long-lived access token in WebSocket connection headers
- **Authentication Header:** `Authorization: Bearer {token}`
- **Rate Limits:** No explicit rate limits, but connection should be stable and persistent
- **Key Endpoints:** WebSocket connection with authentication, Event subscription, Heartbeat

### Data Models and Interfaces
[Source: architecture/data-models.md]

**Configuration Interface:**
```typescript
interface Configuration {
  ha_url: string;
  ha_token_masked: string; // Shows only last 4 characters
  weather_api_key_masked: string; // Shows only last 4 characters
  weather_location: string;
  retention_days: number;
  weather_cache_minutes: number;
}
```

**System Health Interface:**
```typescript
interface ServiceStatus {
  websocket_client: 'healthy' | 'unhealthy';
  enrichment_service: 'healthy' | 'unhealthy';
  influxdb: 'healthy' | 'unhealthy';
  weather_api: 'healthy' | 'unhealthy';
}

interface ConnectionStatus {
  connected: boolean;
  last_reconnect?: string;
  reconnect_count: number;
}
```

### Error Handling Strategy
[Source: architecture/error-handling-strategy.md]

**Backend Error Handling Pattern:**
```python
# Standard error handler
@app.exception_handler(Exception)
async def global_exception_handler(request: Request, exc: Exception):
    logger.error(f"Unhandled error: {str(exc)}", extra={
        "request_id": request.headers.get("x-request-id"),
        "endpoint": str(request.url)
    })
    return JSONResponse(
        status_code=500,
        content={"error": {"code": "INTERNAL_ERROR", "message": "Internal server error"}}
    )
```

### Connection and Reconnection Workflow
[Source: architecture/core-workflows.md]

**Error Handling and Reconnection Workflow:**
- WebSocket connection lost triggers logging and retry process
- Exponential backoff retry mechanism with configurable attempts
- Reconnection includes re-subscribing to events
- Connection health monitoring essential for reliability
- Authentication must be re-established after reconnection

### File Locations
[Source: architecture/unified-project-structure.md]

**WebSocket Ingestion Service Structure:**
```
services/websocket-ingestion/
├── src/
│   ├── __init__.py
│   ├── main.py                # Service entry point
│   ├── websocket_client.py    # HA WebSocket client
│   ├── event_processor.py     # Event processing logic
│   └── health_check.py        # Health monitoring
├── tests/
│   ├── test_websocket_client.py
│   └── test_event_processor.py
├── Dockerfile
└── requirements.txt
```

### Environment Variables
[Source: architecture/development-workflow.md]

**Required Environment Variables:**
```bash
# Home Assistant Configuration
HA_URL=ws://homeassistant.local:8123/api/websocket
HA_ACCESS_TOKEN=your_long_lived_access_token_here

# Logging Configuration
LOG_LEVEL=INFO
LOG_FORMAT=json

# Shared
ENVIRONMENT=development
```

### Testing Requirements
[Source: architecture/testing-strategy.md]

**Backend Test Organization:**
```
services/websocket-ingestion/tests/
├── test_websocket_client.py
├── test_event_processor.py
└── test_health_check.py
```

**Test Examples:**
```python
import pytest
import asyncio
from services.websocket_ingestion.src.websocket_client import WebSocketClient

@pytest.mark.asyncio
async def test_websocket_connection():
    client = WebSocketClient("ws://test-ha:8123/websocket")
    await client.connect()
    
    # Test authentication and connection
    assert client.is_connected()
    assert client.is_authenticated()
```

### Coding Standards
[Source: architecture/coding-standards.md]

**Critical Rules:**
- **Environment Variables:** Access only through config objects, never `process.env` directly
- **Error Handling:** All API routes must use the standard error handler
- **Naming Conventions:** 
  - Functions: snake_case (e.g., `get_connection_status()`)
  - API Routes: kebab-case (e.g., `/api/health-status`)
  - Database Tables: snake_case (e.g., `home_assistant_events`)

### Security Considerations
[Source: architecture/security-and-performance.md]

**Authentication Security:**
- Token Storage: Home Assistant access tokens in environment variables only
- Session Management: Stateless API design, no sessions required
- Password Policy: N/A (uses Home Assistant's existing authentication)

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2024-12-19 | 1.0 | Initial story creation from Epic 1.2 | Scrum Master Bob |

## Dev Agent Record

*This section will be populated by the development agent during implementation*

### Agent Model Used

*To be filled by dev agent*

### Debug Log References

*To be filled by dev agent*

### Completion Notes List

*To be filled by dev agent*

### File List

*To be filled by dev agent*

## QA Results

*Results from QA Agent review will be populated here*
