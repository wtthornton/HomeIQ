# Story 1.3: Advanced Data Visualization - Implementation Guide

## üéØ **Quick Start Implementation**

### **Phase 1: Chart.js Enhancement Setup (Day 1)**
```bash
# Install Chart.js v4 and plugins
npm install chart.js@4
npm install chartjs-plugin-zoom
npm install chartjs-plugin-annotation
npm install react-chartjs-2
```

**Implementation Steps:**
1. **Create enhanced chart component** (`src/components/EnhancedMetricsChart.tsx`):
   ```tsx
   import React, { useRef, useEffect } from 'react';
   import {
     Chart as ChartJS,
     CategoryScale,
     LinearScale,
     PointElement,
     LineElement,
     Title,
     Tooltip,
     Legend,
     Filler
   } from 'chart.js';
   import { Line } from 'react-chartjs-2';
   import zoomPlugin from 'chartjs-plugin-zoom';

   ChartJS.register(
     CategoryScale,
     LinearScale,
     PointElement,
     LineElement,
     Title,
     Tooltip,
     Legend,
     Filler,
     zoomPlugin
   );

   interface EnhancedMetricsChartProps {
     data: ChartData;
     title: string;
     onDataPointClick?: (point: any) => void;
   }

   const EnhancedMetricsChart: React.FC<EnhancedMetricsChartProps> = ({
     data,
     title,
     onDataPointClick
   }) => {
     const chartRef = useRef<ChartJS>(null);

     const options = {
       responsive: true,
       maintainAspectRatio: false,
       interaction: {
         mode: 'nearest' as const,
         intersect: true,
         axis: 'xy' as const
       },
       plugins: {
         zoom: {
           zoom: {
             wheel: { enabled: true },
             pinch: { enabled: true },
             mode: 'xy' as const
           },
           pan: {
             enabled: true,
             mode: 'xy' as const
           }
         },
         tooltip: {
           callbacks: {
             afterLabel: (context: any) => {
               return `Value: ${context.parsed.y}`;
             }
           }
         }
       },
       scales: {
         x: {
           display: true,
           title: {
             display: true,
             text: 'Time'
           }
         },
         y: {
           display: true,
           title: {
             display: true,
             text: 'Value'
           }
         }
       },
       onClick: (event: any, elements: any) => {
         if (elements.length > 0 && onDataPointClick) {
           onDataPointClick(elements[0]);
         }
       }
     };

     return (
       <div className="h-96 w-full">
         <h3 className="text-lg font-semibold mb-4">{title}</h3>
         <Line ref={chartRef} data={data} options={options} />
       </div>
     );
   };

   export default EnhancedMetricsChart;
   ```

### **Phase 2: Custom Chart Plugins (Day 2)**
```tsx
// src/utils/chartPlugins.ts
export const chartAreaBorder = {
  id: 'chartAreaBorder',
  beforeDraw(chart: any, args: any, options: any) {
    const { ctx, chartArea: { left, top, width, height } } = chart;
    ctx.save();
    ctx.strokeStyle = options.borderColor || '#e5e7eb';
    ctx.lineWidth = options.borderWidth || 1;
    ctx.setLineDash(options.borderDash || []);
    ctx.lineDashOffset = options.borderDashOffset || 0;
    ctx.strokeRect(left, top, width, height);
    ctx.restore();
  }
};

export const dataPointHighlighter = {
  id: 'dataPointHighlighter',
  afterDraw(chart: any) {
    const { ctx, chartArea: { left, top, right, bottom } } = chart;
    const { scales: { x, y } } = chart;
    
    ctx.save();
    ctx.strokeStyle = '#3b82f6';
    ctx.lineWidth = 2;
    ctx.setLineDash([5, 5]);
    
    // Draw vertical line at hovered point
    if (chart.tooltip && chart.tooltip.caretX) {
      ctx.beginPath();
      ctx.moveTo(chart.tooltip.caretX, top);
      ctx.lineTo(chart.tooltip.caretX, bottom);
      ctx.stroke();
    }
    
    ctx.restore();
  }
};
```

### **Phase 3: Filtering System (Day 3)**
```tsx
// src/components/ChartFilters.tsx
import React, { useState } from 'react';

interface ChartFiltersProps {
  onFilterChange: (filters: FilterOptions) => void;
  availableFilters: FilterOptions;
}

interface FilterOptions {
  timeRange: string;
  entityType: string;
  eventType: string;
  aggregation: string;
}

const ChartFilters: React.FC<ChartFiltersProps> = ({
  onFilterChange,
  availableFilters
}) => {
  const [filters, setFilters] = useState<FilterOptions>({
    timeRange: '1h',
    entityType: 'all',
    eventType: 'all',
    aggregation: 'average'
  });

  const handleFilterChange = (key: keyof FilterOptions, value: string) => {
    const newFilters = { ...filters, [key]: value };
    setFilters(newFilters);
    onFilterChange(newFilters);
  };

  return (
    <div className="bg-white p-4 rounded-lg shadow mb-4">
      <h3 className="text-lg font-semibold mb-4">Chart Filters</h3>
      <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
        <div>
          <label className="block text-sm font-medium text-gray-700 mb-1">
            Time Range
          </label>
          <select
            value={filters.timeRange}
            onChange={(e) => handleFilterChange('timeRange', e.target.value)}
            className="w-full p-2 border border-gray-300 rounded-md"
          >
            <option value="15m">Last 15 minutes</option>
            <option value="1h">Last hour</option>
            <option value="6h">Last 6 hours</option>
            <option value="24h">Last 24 hours</option>
            <option value="7d">Last 7 days</option>
          </select>
        </div>
        
        <div>
          <label className="block text-sm font-medium text-gray-700 mb-1">
            Entity Type
          </label>
          <select
            value={filters.entityType}
            onChange={(e) => handleFilterChange('entityType', e.target.value)}
            className="w-full p-2 border border-gray-300 rounded-md"
          >
            <option value="all">All Entities</option>
            <option value="sensor">Sensors</option>
            <option value="switch">Switches</option>
            <option value="light">Lights</option>
          </select>
        </div>
        
        <div>
          <label className="block text-sm font-medium text-gray-700 mb-1">
            Event Type
          </label>
          <select
            value={filters.eventType}
            onChange={(e) => handleFilterChange('eventType', e.target.value)}
            className="w-full p-2 border border-gray-300 rounded-md"
          >
            <option value="all">All Events</option>
            <option value="state_changed">State Changes</option>
            <option value="value_changed">Value Changes</option>
            <option value="error">Errors</option>
          </select>
        </div>
        
        <div>
          <label className="block text-sm font-medium text-gray-700 mb-1">
            Aggregation
          </label>
          <select
            value={filters.aggregation}
            onChange={(e) => handleFilterChange('aggregation', e.target.value)}
            className="w-full p-2 border border-gray-300 rounded-md"
          >
            <option value="average">Average</option>
            <option value="sum">Sum</option>
            <option value="min">Minimum</option>
            <option value="max">Maximum</option>
          </select>
        </div>
      </div>
    </div>
  );
};

export default ChartFilters;
```

## üß™ **Testing Implementation**

### **Unit Tests**
```tsx
// src/components/__tests__/EnhancedMetricsChart.test.tsx
import { render, screen } from '@testing-library/react';
import EnhancedMetricsChart from '../EnhancedMetricsChart';

const mockData = {
  labels: ['Jan', 'Feb', 'Mar'],
  datasets: [{
    label: 'Test Data',
    data: [10, 20, 30],
    borderColor: 'rgb(75, 192, 192)',
    backgroundColor: 'rgba(75, 192, 192, 0.2)'
  }]
};

test('renders chart with title', () => {
  render(
    <EnhancedMetricsChart 
      data={mockData} 
      title="Test Chart" 
    />
  );
  
  expect(screen.getByText('Test Chart')).toBeInTheDocument();
});

test('handles data point clicks', () => {
  const mockOnClick = jest.fn();
  render(
    <EnhancedMetricsChart 
      data={mockData} 
      title="Test Chart"
      onDataPointClick={mockOnClick}
    />
  );
  
  // Test click handling (would need more specific implementation)
  expect(mockOnClick).toBeDefined();
});
```

### **Integration Tests**
```tsx
// src/__tests__/ChartFilters.test.tsx
import { render, screen, fireEvent } from '@testing-library/react';
import ChartFilters from '../components/ChartFilters';

test('filter changes trigger callback', () => {
  const mockOnFilterChange = jest.fn();
  const availableFilters = {
    timeRange: ['15m', '1h', '6h'],
    entityType: ['all', 'sensor', 'switch'],
    eventType: ['all', 'state_changed', 'value_changed'],
    aggregation: ['average', 'sum', 'min', 'max']
  };

  render(
    <ChartFilters 
      onFilterChange={mockOnFilterChange}
      availableFilters={availableFilters}
    />
  );

  fireEvent.change(screen.getByDisplayValue('1h'), { target: { value: '6h' } });
  
  expect(mockOnFilterChange).toHaveBeenCalledWith(
    expect.objectContaining({ timeRange: '6h' })
  );
});
```

## üìã **Acceptance Criteria Checklist**

- [ ] Chart.js v4 installed with zoom and annotation plugins
- [ ] Enhanced chart component with zoom/pan functionality
- [ ] Custom plugins for chart area border and data highlighting
- [ ] Filtering system with time range, entity type, and event type
- [ ] Drill-down capabilities on data points
- [ ] Smooth performance with large datasets
- [ ] Unit tests written and passing
- [ ] Integration tests written and passing
- [ ] All existing chart functionality preserved

## üîó **Dependencies**

- **Prerequisites**: Story 1.1 (Foundation & Navigation)
- **Enables**: Story 1.4 (Real-time Notifications), Story 1.6 (Data Export)
- **External**: chart.js@4, chartjs-plugin-zoom, chartjs-plugin-annotation

## ‚ö†Ô∏è **Implementation Notes**

1. **Performance**: Use Chart.js optimization for large datasets
2. **Memory**: Clean up chart instances on component unmount
3. **Responsiveness**: Ensure charts work on mobile devices
4. **Accessibility**: Add ARIA labels for chart elements

## üöÄ **Next Steps After Completion**

Once this story is complete, you can proceed with:
- **Story 1.4**: Real-time Notifications System
- **Story 1.6**: Data Export & Historical Analysis


