# Story 5.2: Health Dashboard Interface

## Status

Ready for Development

## Story

**As a** system administrator,  
**I want** a health dashboard interface,  
**so that** I can monitor system status and performance in real-time.

## Acceptance Criteria

1. Real-time system health status displays service connectivity and status
2. Event processing metrics show events per hour, total today, and error rates
3. Connection health status displays WebSocket connection state and last reconnect information
4. Recent events feed shows latest captured events with entity_id, state changes, and timestamps
5. System resource usage displays CPU, memory, and storage utilization
6. Alert notifications show system issues and configuration problems
7. Dashboard updates automatically with configurable refresh intervals

## Tasks / Subtasks

- [ ] Task 1: Create health dashboard React components
- [ ] Task 2: Implement real-time data fetching and updates
- [ ] Task 3: Create service status visualization components
- [ ] Task 4: Implement event metrics and statistics display
- [ ] Task 5: Create connection health monitoring interface
- [ ] Task 6: Implement recent events feed with filtering
- [ ] Task 7: Add system resource usage monitoring
- [ ] Task 8: Create comprehensive tests

## Dev Notes

### Technology Stack
- **Frontend Framework:** React 18+ with TypeScript
- **Build Tool:** Vite for fast development and building
- **Styling:** Custom CSS for minimal dependencies
- **State Management:** React hooks for component state
- **HTTP Client:** Fetch API for API communication
- **Real-time Updates:** WebSocket client for live data
- **Charts:** Chart.js with react-chartjs-2 for data visualization
- **Date Handling:** date-fns for time operations

### Context7 Implementation Patterns

**Real-time Data Fetching with WebSocket:**
```typescript
import React, { useState, useEffect, useCallback } from 'react';

interface WebSocketData {
  type: 'health' | 'stats' | 'events';
  data: any;
  timestamp: string;
}

interface UseWebSocketResult {
  data: WebSocketData | null;
  isConnected: boolean;
  error: string | null;
  sendMessage: (message: any) => void;
}

export function useWebSocket(url: string): UseWebSocketResult {
  const [data, setData] = useState<WebSocketData | null>(null);
  const [isConnected, setIsConnected] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [ws, setWs] = useState<WebSocket | null>(null);

  useEffect(() => {
    const websocket = new WebSocket(url);
    
    websocket.onopen = () => {
      setIsConnected(true);
      setError(null);
      console.log('WebSocket connected');
    };

    websocket.onmessage = (event) => {
      try {
        const message: WebSocketData = JSON.parse(event.data);
        setData(message);
      } catch (err) {
        setError('Failed to parse WebSocket message');
      }
    };

    websocket.onclose = () => {
      setIsConnected(false);
      console.log('WebSocket disconnected');
    };

    websocket.onerror = (error) => {
      setError('WebSocket connection error');
      console.error('WebSocket error:', error);
    };

    setWs(websocket);

    return () => {
      websocket.close();
    };
  }, [url]);

  const sendMessage = useCallback((message: any) => {
    if (ws && isConnected) {
      ws.send(JSON.stringify(message));
    }
  }, [ws, isConnected]);

  return { data, isConnected, error, sendMessage };
}
```

**Health Dashboard Component with Real-time Updates:**
```typescript
import React, { useState, useEffect } from 'react';
import { useWebSocket } from '../hooks/useWebSocket';
import { ServiceStatus } from './ServiceStatus';
import { EventMetrics } from './EventMetrics';
import { ConnectionHealth } from './ConnectionHealth';
import { RecentEvents } from './RecentEvents';
import { SystemResources } from './SystemResources';

interface HealthDashboardProps {
  apiBaseUrl: string;
  refreshInterval?: number;
}

interface DashboardData {
  health: SystemHealth;
  stats: EventStats;
  events: HomeAssistantEvent[];
  resources: SystemResources;
}

export const HealthDashboard: React.FC<HealthDashboardProps> = ({
  apiBaseUrl,
  refreshInterval = 5000
}) => {
  const [dashboardData, setDashboardData] = useState<DashboardData | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  
  // WebSocket for real-time updates
  const { data: wsData, isConnected } = useWebSocket(`${apiBaseUrl.replace('http', 'ws')}/ws/dashboard`);
  
  // Fetch initial data
  useEffect(() => {
    const fetchDashboardData = async () => {
      try {
        setLoading(true);
        setError(null);
        
        const [healthRes, statsRes, eventsRes, resourcesRes] = await Promise.all([
          fetch(`${apiBaseUrl}/api/health`),
          fetch(`${apiBaseUrl}/api/stats`),
          fetch(`${apiBaseUrl}/api/events/recent?limit=10`),
          fetch(`${apiBaseUrl}/api/resources`)
        ]);

        if (!healthRes.ok || !statsRes.ok || !eventsRes.ok || !resourcesRes.ok) {
          throw new Error('Failed to fetch dashboard data');
        }

        const [health, stats, events, resources] = await Promise.all([
          healthRes.json(),
          statsRes.json(),
          eventsRes.json(),
          resourcesRes.json()
        ]);

        setDashboardData({
          health,
          stats,
          events: events.events || [],
          resources
        });
      } catch (err) {
        setError(err instanceof Error ? err.message : 'Unknown error');
      } finally {
        setLoading(false);
      }
    };

    fetchDashboardData();
    
    // Set up periodic refresh
    const interval = setInterval(fetchDashboardData, refreshInterval);
    
    return () => clearInterval(interval);
  }, [apiBaseUrl, refreshInterval]);

  // Handle WebSocket updates
  useEffect(() => {
    if (wsData && dashboardData) {
      switch (wsData.type) {
        case 'health':
          setDashboardData(prev => prev ? { ...prev, health: wsData.data } : null);
          break;
        case 'stats':
          setDashboardData(prev => prev ? { ...prev, stats: wsData.data } : null);
          break;
        case 'events':
          setDashboardData(prev => prev ? { 
            ...prev, 
            events: [wsData.data, ...prev.events.slice(0, 9)]
          } : null);
          break;
      }
    }
  }, [wsData, dashboardData]);

  if (loading) {
    return (
      <div className="dashboard-loading">
        <div className="loading-spinner"></div>
        <p>Loading dashboard data...</p>
      </div>
    );
  }

  if (error) {
    return (
      <div className="dashboard-error">
        <h2>Dashboard Error</h2>
        <p>{error}</p>
        <button onClick={() => window.location.reload()}>Retry</button>
      </div>
    );
  }

  if (!dashboardData) {
    return <div>No data available</div>;
  }

  return (
    <div className="health-dashboard">
      <div className="dashboard-header">
        <h1>System Health Dashboard</h1>
        <div className="connection-status">
          <span className={`status-indicator ${isConnected ? 'connected' : 'disconnected'}`}>
            {isConnected ? '●' : '○'}
          </span>
          <span>{isConnected ? 'Live Updates' : 'Disconnected'}</span>
        </div>
      </div>

      <div className="dashboard-grid">
        <div className="dashboard-section">
          <ServiceStatus 
            serviceStatus={dashboardData.health.service_status}
            lastUpdated={dashboardData.health.last_updated}
          />
        </div>

        <div className="dashboard-section">
          <EventMetrics 
            eventStats={dashboardData.stats}
            lastUpdated={dashboardData.health.last_updated}
          />
        </div>

        <div className="dashboard-section">
          <ConnectionHealth 
            connectionStatus={dashboardData.health.connection_status}
            lastUpdated={dashboardData.health.last_updated}
          />
        </div>

        <div className="dashboard-section">
          <SystemResources 
            resources={dashboardData.resources}
            lastUpdated={dashboardData.health.last_updated}
          />
        </div>

        <div className="dashboard-section full-width">
          <RecentEvents 
            events={dashboardData.events}
            lastUpdated={dashboardData.health.last_updated}
          />
        </div>
      </div>
    </div>
  );
};
```

**Service Status Component with Visual Indicators:**
```typescript
import React from 'react';
import { format } from 'date-fns';

interface ServiceStatusProps {
  serviceStatus: Record<string, 'healthy' | 'unhealthy'>;
  lastUpdated: string;
}

export const ServiceStatus: React.FC<ServiceStatusProps> = ({
  serviceStatus,
  lastUpdated
}) => {
  const getStatusIcon = (status: string) => {
    return status === 'healthy' ? '✅' : '❌';
  };

  const getStatusClass = (status: string) => {
    return status === 'healthy' ? 'status-healthy' : 'status-unhealthy';
  };

  return (
    <div className="service-status">
      <h2>Service Status</h2>
      <div className="status-list">
        {Object.entries(serviceStatus).map(([service, status]) => (
          <div key={service} className={`status-item ${getStatusClass(status)}`}>
            <span className="status-icon">{getStatusIcon(status)}</span>
            <span className="service-name">{service}</span>
            <span className="service-status-text">{status}</span>
          </div>
        ))}
      </div>
      <div className="last-updated">
        Last updated: {format(new Date(lastUpdated), 'HH:mm:ss')}
      </div>
    </div>
  );
};
```

**Event Metrics Component with Charts:**
```typescript
import React from 'react';
import {
  Chart as ChartJS,
  CategoryScale,
  LinearScale,
  PointElement,
  LineElement,
  Title,
  Tooltip,
  Legend,
} from 'chart.js';
import { Line } from 'react-chartjs-2';

ChartJS.register(
  CategoryScale,
  LinearScale,
  PointElement,
  LineElement,
  Title,
  Tooltip,
  Legend
);

interface EventMetricsProps {
  eventStats: EventStats;
  lastUpdated: string;
}

export const EventMetrics: React.FC<EventMetricsProps> = ({
  eventStats,
  lastUpdated
}) => {
  const chartData = {
    labels: ['Last Hour', 'Current'],
    datasets: [
      {
        label: 'Events per Hour',
        data: [eventStats.events_per_hour * 0.8, eventStats.events_per_hour],
        borderColor: 'rgb(75, 192, 192)',
        backgroundColor: 'rgba(75, 192, 192, 0.2)',
        tension: 0.1,
      },
    ],
  };

  const chartOptions = {
    responsive: true,
    plugins: {
      legend: {
        position: 'top' as const,
      },
      title: {
        display: true,
        text: 'Event Processing Rate',
      },
    },
    scales: {
      y: {
        beginAtZero: true,
      },
    },
  };

  return (
    <div className="event-metrics">
      <h2>Event Metrics</h2>
      
      <div className="metrics-grid">
        <div className="metric-card">
          <div className="metric-value">{eventStats.events_per_hour}</div>
          <div className="metric-label">Events/Hour</div>
        </div>
        
        <div className="metric-card">
          <div className="metric-value">{eventStats.total_events_today}</div>
          <div className="metric-label">Total Today</div>
        </div>
        
        <div className="metric-card">
          <div className="metric-value">{(eventStats.error_rate * 100).toFixed(1)}%</div>
          <div className="metric-label">Error Rate</div>
        </div>
      </div>

      <div className="chart-container">
        <Line data={chartData} options={chartOptions} />
      </div>

      <div className="last-updated">
        Last updated: {new Date(lastUpdated).toLocaleTimeString()}
      </div>
    </div>
  );
};
```

**Custom Hooks for Data Management:**
```typescript
import { useState, useEffect, useCallback } from 'react';

interface UseApiResult<T> {
  data: T | null;
  loading: boolean;
  error: string | null;
  refetch: () => void;
}

export function useApi<T>(url: string, options?: RequestInit): UseApiResult<T> {
  const [data, setData] = useState<T | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const fetchData = useCallback(async () => {
    try {
      setLoading(true);
      setError(null);
      
      const response = await fetch(url, options);
      
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      
      const result = await response.json();
      setData(result);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Unknown error');
    } finally {
      setLoading(false);
    }
  }, [url, options]);

  useEffect(() => {
    fetchData();
  }, [fetchData]);

  return { data, loading, error, refetch: fetchData };
}

// Hook for periodic data updates
export function usePeriodicApi<T>(
  url: string, 
  interval: number = 5000,
  options?: RequestInit
): UseApiResult<T> {
  const apiResult = useApi<T>(url, options);

  useEffect(() => {
    if (interval > 0) {
      const timer = setInterval(apiResult.refetch, interval);
      return () => clearInterval(timer);
    }
  }, [apiResult.refetch, interval]);

  return apiResult;
}
```

### File Structure
```
services/admin-web/
├── src/
│   ├── components/
│   │   ├── HealthDashboard.tsx
│   │   ├── ServiceStatus.tsx
│   │   ├── EventMetrics.tsx
│   │   ├── ConnectionHealth.tsx
│   │   ├── RecentEvents.tsx
│   │   └── SystemResources.tsx
│   ├── hooks/
│   │   ├── useWebSocket.ts
│   │   ├── useApi.ts
│   │   └── usePeriodicApi.ts
│   ├── services/
│   │   ├── api.ts
│   │   └── websocket.ts
│   ├── types/
│   │   ├── api.ts
│   │   └── dashboard.ts
│   ├── utils/
│   │   ├── formatters.ts
│   │   └── validators.ts
│   └── styles/
│       ├── dashboard.css
│       └── components.css
├── tests/
│   ├── components/
│   ├── hooks/
│   └── utils/
├── package.json
└── vite.config.ts
```

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2024-12-19 | 1.0 | Initial story creation from Epic 5.2 | Scrum Master Bob |
