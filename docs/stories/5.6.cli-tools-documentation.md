# Story 5.6: CLI Tools & Documentation

## Status

Ready for Development

## Story

**As a** power user,  
**I want** CLI tools and comprehensive documentation,  
**so that** I can manage the system efficiently and troubleshoot issues.

## Acceptance Criteria

1. CLI tools provide system management and monitoring capabilities
2. Configuration management CLI enables settings updates and validation
3. Data export CLI allows bulk data extraction and analysis
4. System health CLI provides quick status checks and diagnostics
5. Comprehensive documentation covers installation, configuration, and usage
6. Troubleshooting guide addresses common issues and solutions
7. API documentation provides complete endpoint reference and examples

## Tasks / Subtasks

- [ ] Task 1: Create CLI tool framework and base commands
- [ ] Task 2: Implement system management CLI commands
- [ ] Task 3: Add configuration management CLI functionality
- [ ] Task 4: Create data export CLI tools
- [ ] Task 5: Implement system health CLI diagnostics
- [ ] Task 6: Create comprehensive user documentation
- [ ] Task 7: Add troubleshooting guide and common solutions
- [ ] Task 8: Create comprehensive tests

## Dev Notes

### Technology Stack
- **CLI Framework:** Typer for modern Python CLI tools with type hints
- **Documentation:** Markdown with automated generation
- **API Documentation:** OpenAPI with interactive examples
- **Testing:** pytest for CLI tool testing
- **Configuration:** Pydantic for settings management
- **Logging:** Rich for beautiful CLI output
- **Progress:** Rich progress bars for long operations

### Context7 Implementation Patterns

**Main CLI Application with Typer:**
```python
# tools/cli/main.py
import typer
from typing import Optional, List
from rich.console import Console
from rich.table import Table
from rich.progress import Progress, SpinnerColumn, TextColumn
import asyncio
import json
from datetime import datetime

from .commands import health, config, export, monitor
from .utils import get_api_client, format_timestamp, validate_config

app = typer.Typer(
    name="ha-ingestor",
    help="Home Assistant Ingestion Layer CLI",
    add_completion=False,
    rich_markup_mode="rich"
)

console = Console()

# Global options
@app.callback()
def main(
    api_url: str = typer.Option(
        "http://localhost:8080",
        "--api-url",
        "-u",
        help="API base URL"
    ),
    verbose: bool = typer.Option(
        False,
        "--verbose",
        "-v",
        help="Enable verbose output"
    ),
    config_file: Optional[str] = typer.Option(
        None,
        "--config",
        "-c",
        help="Configuration file path"
    )
):
    """Home Assistant Ingestion Layer CLI Tool"""
    pass

# Health commands
@app.command()
def health_check(
    detailed: bool = typer.Option(False, "--detailed", "-d", help="Show detailed health information"),
    json_output: bool = typer.Option(False, "--json", "-j", help="Output in JSON format")
):
    """Check system health status"""
    asyncio.run(health.check_health(detailed, json_output))

@app.command()
def health_history(
    hours: int = typer.Option(24, "--hours", "-h", help="Number of hours to show"),
    json_output: bool = typer.Option(False, "--json", "-j", help="Output in JSON format")
):
    """Show health check history"""
    asyncio.run(health.show_health_history(hours, json_output))

# Configuration commands
@app.command()
def config_show(
    json_output: bool = typer.Option(False, "--json", "-j", help="Output in JSON format")
):
    """Show current configuration"""
    asyncio.run(config.show_config(json_output))

@app.command()
def config_set(
    key: str = typer.Argument(..., help="Configuration key"),
    value: str = typer.Argument(..., help="Configuration value")
):
    """Set configuration value"""
    asyncio.run(config.set_config(key, value))

@app.command()
def config_validate():
    """Validate current configuration"""
    asyncio.run(config.validate_config())

# Export commands
@app.command()
def export_events(
    output_file: str = typer.Option("events.json", "--output", "-o", help="Output file path"),
    format: str = typer.Option("json", "--format", "-f", help="Export format (json, csv)"),
    start_time: Optional[str] = typer.Option(None, "--start", "-s", help="Start time (ISO format)"),
    end_time: Optional[str] = typer.Option(None, "--end", "-e", help="End time (ISO format)"),
    entity_id: Optional[str] = typer.Option(None, "--entity", help="Filter by entity ID"),
    limit: int = typer.Option(1000, "--limit", "-l", help="Maximum number of events")
):
    """Export events to file"""
    asyncio.run(export.export_events(
        output_file, format, start_time, end_time, entity_id, limit
    ))

@app.command()
def export_stats(
    output_file: str = typer.Option("stats.json", "--output", "-o", help="Output file path"),
    days: int = typer.Option(7, "--days", "-d", help="Number of days to include")
):
    """Export system statistics"""
    asyncio.run(export.export_stats(output_file, days))

# Monitoring commands
@app.command()
def monitor_live(
    refresh_interval: int = typer.Option(5, "--interval", "-i", help="Refresh interval in seconds"),
    show_events: bool = typer.Option(True, "--events", help="Show recent events"),
    show_metrics: bool = typer.Option(True, "--metrics", help="Show system metrics")
):
    """Monitor system in real-time"""
    asyncio.run(monitor.live_monitor(refresh_interval, show_events, show_metrics))

@app.command()
def monitor_alerts():
    """Show current system alerts"""
    asyncio.run(monitor.show_alerts())

if __name__ == "__main__":
    app()
```

**Health Command Implementation:**
```python
# tools/cli/commands/health.py
import typer
import asyncio
import aiohttp
import json
from typing import Optional
from rich.console import Console
from rich.table import Table
from rich.panel import Panel
from rich.progress import Progress, SpinnerColumn, TextColumn
from datetime import datetime, timedelta

console = Console()

async def check_health(detailed: bool = False, json_output: bool = False):
    """Check system health status"""
    async with aiohttp.ClientSession() as session:
        try:
            async with session.get("http://localhost:8080/api/health") as response:
                if response.status == 200:
                    health_data = await response.json()
                    
                    if json_output:
                        console.print(json.dumps(health_data, indent=2))
                        return
                    
                    # Display health status
                    if health_data.get("status") == "healthy":
                        console.print("✅ [green]System is healthy[/green]")
                    else:
                        console.print("❌ [red]System has issues[/red]")
                    
                    if detailed:
                        await _display_detailed_health(health_data)
                    else:
                        await _display_summary_health(health_data)
                        
                else:
                    console.print(f"❌ [red]Health check failed: HTTP {response.status}[/red]")
                    
        except aiohttp.ClientError as e:
            console.print(f"❌ [red]Connection error: {e}[/red]")
        except Exception as e:
            console.print(f"❌ [red]Unexpected error: {e}[/red]")

async def _display_summary_health(health_data: dict):
    """Display summary health information"""
    table = Table(title="System Health Summary")
    table.add_column("Service", style="cyan")
    table.add_column("Status", style="green")
    table.add_column("Last Updated", style="yellow")
    
    service_status = health_data.get("service_status", {})
    for service, status in service_status.items():
        status_icon = "✅" if status == "healthy" else "❌"
        table.add_row(
            service.replace("_", " ").title(),
            f"{status_icon} {status}",
            format_timestamp(health_data.get("last_updated"))
        )
    
    console.print(table)

async def _display_detailed_health(health_data: dict):
    """Display detailed health information"""
    # Service status table
    service_table = Table(title="Service Status")
    service_table.add_column("Service", style="cyan")
    service_table.add_column("Status", style="green")
    service_table.add_column("Details", style="yellow")
    
    service_status = health_data.get("service_status", {})
    for service, status in service_status.items():
        status_icon = "✅" if status == "healthy" else "❌"
        service_table.add_row(
            service.replace("_", " ").title(),
            f"{status_icon} {status}",
            "Running normally" if status == "healthy" else "Check logs for details"
        )
    
    console.print(service_table)
    
    # Event statistics
    event_stats = health_data.get("event_stats", {})
    if event_stats:
        stats_panel = Panel(
            f"Events/Hour: {event_stats.get('events_per_hour', 'N/A')}\\n"
            f"Total Today: {event_stats.get('total_events_today', 'N/A')}\\n"
            f"Error Rate: {event_stats.get('error_rate', 'N/A')}\\n"
            f"Last Event: {event_stats.get('last_event_time', 'N/A')}",
            title="Event Statistics",
            border_style="blue"
        )
        console.print(stats_panel)

async def show_health_history(hours: int = 24, json_output: bool = False):
    """Show health check history"""
    async with aiohttp.ClientSession() as session:
        try:
            async with session.get(f"http://localhost:8080/api/health/history?hours={hours}") as response:
                if response.status == 200:
                    history_data = await response.json()
                    
                    if json_output:
                        console.print(json.dumps(history_data, indent=2))
                        return
                    
                    # Display history table
                    table = Table(title=f"Health History (Last {hours} hours)")
                    table.add_column("Timestamp", style="cyan")
                    table.add_column("Status", style="green")
                    table.add_column("Services", style="yellow")
                    table.add_column("Events/Hour", style="blue")
                    
                    for entry in history_data.get("history", []):
                        status_icon = "✅" if entry.get("status") == "healthy" else "❌"
                        services_healthy = sum(1 for s in entry.get("service_status", {}).values() if s == "healthy")
                        total_services = len(entry.get("service_status", {}))
                        
                        table.add_row(
                            format_timestamp(entry.get("timestamp")),
                            f"{status_icon} {entry.get('status', 'unknown')}",
                            f"{services_healthy}/{total_services}",
                            str(entry.get("event_stats", {}).get("events_per_hour", "N/A"))
                        )
                    
                    console.print(table)
                else:
                    console.print(f"❌ [red]Failed to get health history: HTTP {response.status}[/red]")
                    
        except Exception as e:
            console.print(f"❌ [red]Error getting health history: {e}[/red]")

def format_timestamp(timestamp: str) -> str:
    """Format timestamp for display"""
    if not timestamp:
        return "N/A"
    try:
        dt = datetime.fromisoformat(timestamp.replace('Z', '+00:00'))
        return dt.strftime("%Y-%m-%d %H:%M:%S")
    except:
        return timestamp
```

**Configuration Command Implementation:**
```python
# tools/cli/commands/config.py
import typer
import asyncio
import aiohttp
import json
from typing import Optional, Dict, Any
from rich.console import Console
from rich.table import Table
from rich.panel import Panel
from pydantic import BaseModel, ValidationError

console = Console()

class ConfigurationModel(BaseModel):
    ha_url: str
    ha_token_masked: str
    weather_api_key_masked: str
    weather_location: str
    retention_days: int
    weather_cache_minutes: int
    last_updated: str

async def show_config(json_output: bool = False):
    """Show current configuration"""
    async with aiohttp.ClientSession() as session:
        try:
            async with session.get("http://localhost:8080/api/config") as response:
                if response.status == 200:
                    config_data = await response.json()
                    
                    if json_output:
                        console.print(json.dumps(config_data, indent=2))
                        return
                    
                    # Display configuration table
                    table = Table(title="Current Configuration")
                    table.add_column("Setting", style="cyan")
                    table.add_column("Value", style="green")
                    table.add_column("Type", style="yellow")
                    
                    for key, value in config_data.items():
                        if key == "last_updated":
                            table.add_row(key.replace("_", " ").title(), str(value), "timestamp")
                        elif "masked" in key:
                            table.add_row(key.replace("_", " ").title(), str(value), "masked")
                        else:
                            table.add_row(key.replace("_", " ").title(), str(value), type(value).__name__)
                    
                    console.print(table)
                else:
                    console.print(f"❌ [red]Failed to get configuration: HTTP {response.status}[/red]")
                    
        except Exception as e:
            console.print(f"❌ [red]Error getting configuration: {e}[/red]")

async def set_config(key: str, value: str):
    """Set configuration value"""
    # Validate the key
    valid_keys = ["weather_location", "retention_days", "weather_cache_minutes"]
    if key not in valid_keys:
        console.print(f"❌ [red]Invalid configuration key. Valid keys: {', '.join(valid_keys)}[/red]")
        return
    
    # Convert value to appropriate type
    try:
        if key in ["retention_days", "weather_cache_minutes"]:
            converted_value = int(value)
        else:
            converted_value = value
    except ValueError:
        console.print(f"❌ [red]Invalid value for {key}. Expected integer for numeric fields.[/red]")
        return
    
    # Update configuration
    async with aiohttp.ClientSession() as session:
        try:
            update_data = {key: converted_value}
            async with session.put(
                "http://localhost:8080/api/config",
                json=update_data,
                headers={"Content-Type": "application/json"}
            ) as response:
                if response.status == 200:
                    result = await response.json()
                    console.print(f"✅ [green]Configuration updated successfully[/green]")
                    console.print(f"Updated {key} to {converted_value}")
                else:
                    error_data = await response.json()
                    console.print(f"❌ [red]Failed to update configuration: {error_data.get('detail', 'Unknown error')}[/red]")
                    
        except Exception as e:
            console.print(f"❌ [red]Error updating configuration: {e}[/red]")

async def validate_config():
    """Validate current configuration"""
    async with aiohttp.ClientSession() as session:
        try:
            async with session.get("http://localhost:8080/api/config/validate") as response:
                if response.status == 200:
                    validation_data = await response.json()
                    
                    if validation_data.get("valid", False):
                        console.print("✅ [green]Configuration is valid[/green]")
                    else:
                        console.print("❌ [red]Configuration has issues[/red]")
                        
                        issues = validation_data.get("issues", [])
                        for issue in issues:
                            console.print(f"  • {issue}")
                            
                else:
                    console.print(f"❌ [red]Failed to validate configuration: HTTP {response.status}[/red]")
                    
        except Exception as e:
            console.print(f"❌ [red]Error validating configuration: {e}[/red]")
```

**Export Command Implementation:**
```python
# tools/cli/commands/export.py
import typer
import asyncio
import aiohttp
import json
import csv
from typing import Optional, List, Dict, Any
from rich.console import Console
from rich.progress import Progress, SpinnerColumn, TextColumn, BarColumn, TimeElapsedColumn
from datetime import datetime
import os

console = Console()

async def export_events(
    output_file: str,
    format: str,
    start_time: Optional[str],
    end_time: Optional[str],
    entity_id: Optional[str],
    limit: int
):
    """Export events to file"""
    
    # Build query parameters
    params = {"limit": limit}
    if start_time:
        params["start_time"] = start_time
    if end_time:
        params["end_time"] = end_time
    if entity_id:
        params["entity_id"] = entity_id
    
    async with aiohttp.ClientSession() as session:
        try:
            with Progress(
                SpinnerColumn(),
                TextColumn("[progress.description]{task.description}"),
                BarColumn(),
                TimeElapsedColumn(),
                console=console
            ) as progress:
                
                task = progress.add_task("Fetching events...", total=None)
                
                async with session.get("http://localhost:8080/api/events/query", params=params) as response:
                    if response.status == 200:
                        data = await response.json()
                        events = data.get("events", [])
                        
                        progress.update(task, description=f"Exporting {len(events)} events...")
                        
                        # Export based on format
                        if format.lower() == "json":
                            await _export_json(events, output_file)
                        elif format.lower() == "csv":
                            await _export_csv(events, output_file)
                        else:
                            console.print(f"❌ [red]Unsupported format: {format}[/red]")
                            return
                        
                        console.print(f"✅ [green]Exported {len(events)} events to {output_file}[/green]")
                        
                    else:
                        console.print(f"❌ [red]Failed to fetch events: HTTP {response.status}[/red]")
                        
        except Exception as e:
            console.print(f"❌ [red]Error exporting events: {e}[/red]")

async def _export_json(events: List[Dict[str, Any]], output_file: str):
    """Export events as JSON"""
    export_data = {
        "exported_at": datetime.utcnow().isoformat(),
        "total_events": len(events),
        "events": events
    }
    
    with open(output_file, 'w') as f:
        json.dump(export_data, f, indent=2)

async def _export_csv(events: List[Dict[str, Any]], output_file: str):
    """Export events as CSV"""
    if not events:
        return
    
    # Get all possible field names
    fieldnames = set()
    for event in events:
        fieldnames.update(event.keys())
    
    fieldnames = sorted(list(fieldnames))
    
    with open(output_file, 'w', newline='') as f:
        writer = csv.DictWriter(f, fieldnames=fieldnames)
        writer.writeheader()
        writer.writerows(events)

async def export_stats(output_file: str, days: int):
    """Export system statistics"""
    async with aiohttp.ClientSession() as session:
        try:
            with Progress(
                SpinnerColumn(),
                TextColumn("[progress.description]{task.description}"),
                console=console
            ) as progress:
                
                task = progress.add_task("Fetching statistics...", total=None)
                
                async with session.get(f"http://localhost:8080/api/stats/history?days={days}") as response:
                    if response.status == 200:
                        stats_data = await response.json()
                        
                        progress.update(task, description="Exporting statistics...")
                        
                        export_data = {
                            "exported_at": datetime.utcnow().isoformat(),
                            "period_days": days,
                            "statistics": stats_data
                        }
                        
                        with open(output_file, 'w') as f:
                            json.dump(export_data, f, indent=2)
                        
                        console.print(f"✅ [green]Exported statistics to {output_file}[/green]")
                        
                    else:
                        console.print(f"❌ [red]Failed to fetch statistics: HTTP {response.status}[/red]")
                        
        except Exception as e:
            console.print(f"❌ [red]Error exporting statistics: {e}[/red]")
```

**Monitoring Command Implementation:**
```python
# tools/cli/commands/monitor.py
import typer
import asyncio
import aiohttp
import json
from typing import Optional
from rich.console import Console
from rich.table import Table
from rich.live import Live
from rich.layout import Layout
from rich.panel import Panel
from rich.text import Text
from datetime import datetime
import signal
import sys

console = Console()

class MonitorState:
    def __init__(self):
        self.running = True
        self.data = {}
        self.last_update = None

monitor_state = MonitorState()

def signal_handler(signum, frame):
    """Handle Ctrl+C gracefully"""
    monitor_state.running = False
    console.print("\\n[yellow]Stopping monitor...[/yellow]")
    sys.exit(0)

signal.signal(signal.SIGINT, signal_handler)

async def live_monitor(refresh_interval: int = 5, show_events: bool = True, show_metrics: bool = True):
    """Monitor system in real-time"""
    
    def make_layout() -> Layout:
        layout = Layout()
        layout.split_column(
            Layout(name="header", size=3),
            Layout(name="main"),
            Layout(name="footer", size=3)
        )
        layout["main"].split_row(
            Layout(name="left"),
            Layout(name="right")
        )
        return layout
    
    layout = make_layout()
    
    with Live(layout, refresh_per_second=1, console=console) as live:
        while monitor_state.running:
            try:
                await _update_monitor_data()
                _update_layout(layout, show_events, show_metrics)
                await asyncio.sleep(refresh_interval)
            except KeyboardInterrupt:
                break
            except Exception as e:
                console.print(f"❌ [red]Monitor error: {e}[/red]")
                await asyncio.sleep(refresh_interval)

async def _update_monitor_data():
    """Update monitor data from API"""
    async with aiohttp.ClientSession() as session:
        try:
            # Get health data
            async with session.get("http://localhost:8080/api/health") as response:
                if response.status == 200:
                    monitor_state.data["health"] = await response.json()
            
            # Get stats data
            async with session.get("http://localhost:8080/api/stats") as response:
                if response.status == 200:
                    monitor_state.data["stats"] = await response.json()
            
            # Get recent events
            async with session.get("http://localhost:8080/api/events/recent?limit=10") as response:
                if response.status == 200:
                    monitor_state.data["events"] = await response.json()
            
            monitor_state.last_update = datetime.now()
            
        except Exception as e:
            console.print(f"❌ [red]Error updating data: {e}[/red]")

def _update_layout(layout: Layout, show_events: bool, show_metrics: bool):
    """Update the live layout"""
    # Header
    header_text = Text("Home Assistant Ingestion Monitor", style="bold blue")
    if monitor_state.last_update:
        header_text.append(f" (Last update: {monitor_state.last_update.strftime('%H:%M:%S')})", style="dim")
    layout["header"].update(Panel(header_text))
    
    # Left panel - Health and Stats
    left_content = []
    
    # Health status
    health_data = monitor_state.data.get("health", {})
    if health_data:
        status = health_data.get("status", "unknown")
        status_color = "green" if status == "healthy" else "red"
        left_content.append(f"System Status: [{status_color}]{status}[/{status_color}]")
        
        # Service status
        service_status = health_data.get("service_status", {})
        for service, status in service_status.items():
            status_icon = "✅" if status == "healthy" else "❌"
            left_content.append(f"  {status_icon} {service.replace('_', ' ').title()}")
    
    # Metrics
    if show_metrics:
        stats_data = monitor_state.data.get("stats", {})
        if stats_data:
            left_content.append("")
            left_content.append("Metrics:")
            left_content.append(f"  Events/Hour: {stats_data.get('events_per_hour', 'N/A')}")
            left_content.append(f"  Total Today: {stats_data.get('total_events_today', 'N/A')}")
            left_content.append(f"  Error Rate: {stats_data.get('error_rate', 'N/A')}")
    
    layout["left"].update(Panel("\\n".join(left_content), title="System Status"))
    
    # Right panel - Recent Events
    if show_events:
        events_data = monitor_state.data.get("events", {})
        events = events_data.get("events", [])
        
        if events:
            events_table = Table(show_header=True, header_style="bold magenta")
            events_table.add_column("Time", style="dim", width=8)
            events_table.add_column("Entity", style="cyan")
            events_table.add_column("State", style="green")
            
            for event in events[:5]:  # Show only last 5 events
                timestamp = datetime.fromisoformat(event.get("last_changed", "").replace('Z', '+00:00'))
                events_table.add_row(
                    timestamp.strftime("%H:%M:%S"),
                    event.get("entity_id", "N/A"),
                    event.get("state", "N/A")
                )
            
            layout["right"].update(Panel(events_table, title="Recent Events"))
        else:
            layout["right"].update(Panel("No recent events", title="Recent Events"))
    
    # Footer
    footer_text = Text("Press Ctrl+C to stop monitoring", style="dim")
    layout["footer"].update(Panel(footer_text))

async def show_alerts():
    """Show current system alerts"""
    async with aiohttp.ClientSession() as session:
        try:
            async with session.get("http://localhost:8080/api/alerts") as response:
                if response.status == 200:
                    alerts_data = await response.json()
                    alerts = alerts_data.get("alerts", [])
                    
                    if alerts:
                        table = Table(title="System Alerts")
                        table.add_column("Severity", style="red")
                        table.add_column("Message", style="yellow")
                        table.add_column("Timestamp", style="cyan")
                        
                        for alert in alerts:
                            table.add_row(
                                alert.get("severity", "unknown"),
                                alert.get("message", "No message"),
                                alert.get("timestamp", "N/A")
                            )
                        
                        console.print(table)
                    else:
                        console.print("✅ [green]No active alerts[/green]")
                        
                else:
                    console.print(f"❌ [red]Failed to get alerts: HTTP {response.status}[/red]")
                    
        except Exception as e:
            console.print(f"❌ [red]Error getting alerts: {e}[/red]")
```

**CLI Testing with pytest:**
```python
# tools/cli/tests/test_cli.py
import pytest
import typer.testing
from unittest.mock import AsyncMock, patch
import json

from cli.main import app

runner = typer.testing.CliRunner()

@pytest.fixture
def mock_api_responses():
    """Mock API responses for testing"""
    with patch('aiohttp.ClientSession') as mock_session:
        mock_response = AsyncMock()
        mock_response.status = 200
        mock_response.json.return_value = {
            "status": "healthy",
            "service_status": {
                "websocket_client": "healthy",
                "influxdb": "healthy"
            },
            "last_updated": "2024-01-01T00:00:00Z"
        }
        
        mock_session.return_value.__aenter__.return_value.get.return_value.__aenter__.return_value = mock_response
        
        yield mock_response

def test_health_check_command(mock_api_responses):
    """Test health check command"""
    result = runner.invoke(app, ["health-check"])
    assert result.exit_code == 0
    assert "System is healthy" in result.output

def test_health_check_json_output(mock_api_responses):
    """Test health check with JSON output"""
    result = runner.invoke(app, ["health-check", "--json"])
    assert result.exit_code == 0
    
    # Parse JSON output
    output_lines = result.output.strip().split('\\n')
    json_output = '\\n'.join(output_lines[1:])  # Skip the first line
    data = json.loads(json_output)
    assert data["status"] == "healthy"

def test_config_show_command():
    """Test config show command"""
    with patch('aiohttp.ClientSession') as mock_session:
        mock_response = AsyncMock()
        mock_response.status = 200
        mock_response.json.return_value = {
            "ha_url": "ws://localhost:8123",
            "weather_location": "New York",
            "retention_days": 30
        }
        
        mock_session.return_value.__aenter__.return_value.get.return_value.__aenter__.return_value = mock_response
        
        result = runner.invoke(app, ["config-show"])
        assert result.exit_code == 0
        assert "Current Configuration" in result.output

def test_config_set_command():
    """Test config set command"""
    with patch('aiohttp.ClientSession') as mock_session:
        mock_response = AsyncMock()
        mock_response.status = 200
        mock_response.json.return_value = {"message": "Configuration updated"}
        
        mock_session.return_value.__aenter__.return_value.put.return_value.__aenter__.return_value = mock_response
        
        result = runner.invoke(app, ["config-set", "weather_location", "London"])
        assert result.exit_code == 0
        assert "Configuration updated successfully" in result.output

def test_export_events_command():
    """Test export events command"""
    with patch('aiohttp.ClientSession') as mock_session:
        mock_response = AsyncMock()
        mock_response.status = 200
        mock_response.json.return_value = {
            "events": [
                {"entity_id": "sensor.temp", "state": "22.5", "last_changed": "2024-01-01T00:00:00Z"}
            ]
        }
        
        mock_session.return_value.__aenter__.return_value.get.return_value.__aenter__.return_value = mock_response
        
        with patch('builtins.open', create=True) as mock_open:
            result = runner.invoke(app, ["export-events", "--output", "test.json", "--format", "json"])
            assert result.exit_code == 0
            assert "Exported 1 events" in result.output
```

### File Structure
```
tools/
├── cli/
│   ├── __init__.py
│   ├── main.py
│   ├── commands/
│   │   ├── __init__.py
│   │   ├── health.py
│   │   ├── config.py
│   │   ├── export.py
│   │   └── monitor.py
│   ├── utils/
│   │   ├── __init__.py
│   │   ├── api_client.py
│   │   └── formatters.py
│   ├── tests/
│   │   ├── __init__.py
│   │   ├── test_cli.py
│   │   ├── test_commands.py
│   │   └── conftest.py
│   ├── requirements.txt
│   └── pyproject.toml
├── docs/
│   ├── INSTALLATION.md
│   ├── CONFIGURATION.md
│   ├── USAGE.md
│   ├── TROUBLESHOOTING.md
│   ├── API.md
│   └── CLI_REFERENCE.md
└── scripts/
    ├── generate_docs.py
    └── test_cli.py
```

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2024-12-19 | 1.0 | Initial story creation from Epic 5.6 | Scrum Master Bob |
