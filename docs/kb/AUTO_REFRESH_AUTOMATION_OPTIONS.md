# Auto-Refresh Automation Options
**Created:** October 12, 2025  
**Purpose:** Evaluate automation levels with honest trade-offs

---

## üéØ Current State (Manual)

```bash
# User manually runs commands
*context7-kb-refresh --check-only
*context7-kb-refresh
*context7-kb-process-queue
```

**Pros:**
- ‚úÖ User has full control
- ‚úÖ No surprises
- ‚úÖ Simple to understand
- ‚úÖ Zero complexity

**Cons:**
- ‚ùå User must remember to run
- ‚ùå Cache can get stale if forgotten
- ‚ùå Manual work required

---

## üîÑ Automation Level 1: Auto-Process Queue on Startup
**Complexity:** LOW | **Time:** 30 minutes | **Value:** MEDIUM

### What It Does
When any BMAD agent activates, automatically process the refresh queue (if not empty).

### Implementation
Add to agent activation instructions:

```yaml
activation-instructions:
  - STEP 3b: Check and auto-process refresh queue
    if os.path.exists('docs/kb/context7-cache/.refresh-queue'):
        auto_process_queue_silently()
```

### Changes Required
- Modify 9 agent activation instructions
- Add silent queue processing function
- Show brief message: "üîÑ Processing 2 queued refreshes... ‚úÖ Done"

### Pros
- ‚úÖ Queue processed automatically
- ‚úÖ No user action needed
- ‚úÖ Still simple (just a startup check)
- ‚úÖ Minimal code (~50 lines)

### Cons
- ‚ö†Ô∏è Slight delay on agent startup (2-5 seconds)
- ‚ö†Ô∏è May surprise users initially
- ‚ö†Ô∏è Uses API calls on startup

### Recommended?
**YES** - This is the sweet spot for "a little more automatic"

---

## üîÑ Automation Level 2: Auto-Check on First Access
**Complexity:** LOW | **Time:** 1 hour | **Value:** HIGH

### What It Does
First time user accesses KB in a session, auto-check staleness and queue stale items.

### Implementation
Add session tracking to KB lookup:

```python
# Simple session tracking
SESSION_STARTED = False

def context7_docs(library, topic):
    global SESSION_STARTED
    
    # On first access, check all cache entries
    if not SESSION_STARTED:
        SESSION_STARTED = True
        stale_items = check_all_cache_staleness()
        if stale_items:
            print(f"üìã Found {len(stale_items)} stale cache entries")
            print(f"üí° Run *context7-kb-process-queue to refresh")
            # Auto-queue them
            for item in stale_items:
                queue_refresh(item)
    
    # Normal lookup
    return kb_lookup(library, topic)
```

### Changes Required
- Add session tracking variable
- Modify KB lookup to check on first access
- Auto-queue stale items
- Show user notification once per session

### Pros
- ‚úÖ User is informed automatically
- ‚úÖ Stale items auto-queued
- ‚úÖ Only happens once per session
- ‚úÖ Still user-controlled (queue processing)

### Cons
- ‚ö†Ô∏è First lookup slightly slower (~500ms)
- ‚ö†Ô∏è Global state (SESSION_STARTED)
- ‚ö†Ô∏è May check more often than needed

### Recommended?
**YES** - Good balance of automation and control

---

## üîÑ Automation Level 3: Auto-Refresh on Access (If Stale)
**Complexity:** MEDIUM | **Time:** 2 hours | **Value:** HIGH

### What It Does
When accessing a stale cache entry, auto-refresh it immediately (with timeout).

### Implementation

```python
def context7_docs(library, topic):
    cached = read_kb_cache(library, topic)
    
    if cached:
        if is_cache_stale(library):
            print(f"‚ö†Ô∏è  Cache is stale ({get_age(library)} days old)")
            print(f"üîÑ Refreshing now (this will take ~2 seconds)...")
            
            # Refresh synchronously with timeout
            try:
                new_docs = fetch_from_context7_with_timeout(library, topic, timeout=5)
                update_cache(library, topic, new_docs)
                update_last_checked(library)
                print(f"‚úÖ Cache refreshed!")
                return new_docs
            except TimeoutError:
                print(f"‚ö†Ô∏è  Refresh timeout, using cached docs")
                queue_refresh(library, topic)
                return cached
        else:
            print(f"üìÑ Using cached docs (verified fresh)")
            return cached
    
    # Cache miss - fetch normally
    return fetch_and_cache_from_context7(library, topic)
```

### Changes Required
- Add timeout to Context7 API calls
- Modify KB lookup to refresh synchronously
- Add progress indicators
- Graceful fallback to cached on timeout

### Pros
- ‚úÖ Always get fresh docs
- ‚úÖ Automatic refresh
- ‚úÖ Still shows progress
- ‚úÖ Fallback to cache if slow

### Cons
- ‚ö†Ô∏è Blocks user for 2-5 seconds on stale access
- ‚ö†Ô∏è May make unexpected API calls
- ‚ö†Ô∏è Uses API quota automatically

### Recommended?
**MAYBE** - Good if you want "always fresh" but adds blocking

---

## üîÑ Automation Level 4: Background Thread Processing
**Complexity:** HIGH | **Time:** 1 day | **Value:** MEDIUM

### What It Does
Start a background thread that processes refresh queue every N minutes.

### Implementation

```python
import threading
import time

class BackgroundRefresher:
    def __init__(self, interval_minutes=60):
        self.interval = interval_minutes * 60
        self.running = False
        self.thread = None
    
    def start(self):
        if self.running:
            return
        
        self.running = True
        self.thread = threading.Thread(target=self._refresh_loop, daemon=True)
        self.thread.start()
    
    def stop(self):
        self.running = False
        if self.thread:
            self.thread.join(timeout=5)
    
    def _refresh_loop(self):
        while self.running:
            try:
                # Check queue
                queue = get_refresh_queue()
                if queue:
                    print(f"üîÑ [Background] Processing {len(queue)} items...")
                    process_refresh_queue()
                    print(f"‚úÖ [Background] Queue processed")
            except Exception as e:
                print(f"‚ö†Ô∏è  [Background] Error: {e}")
            
            # Sleep until next check
            time.sleep(self.interval)

# Start on agent activation
refresher = BackgroundRefresher(interval_minutes=60)
refresher.start()
```

### Changes Required
- Add threading import
- Create background refresher class
- Start/stop on agent activation/exit
- Handle thread lifecycle
- Add error handling
- Configure interval

### Pros
- ‚úÖ Fully automatic
- ‚úÖ No user intervention
- ‚úÖ Queue processed regularly
- ‚úÖ Runs in background

### Cons
- ‚ùå Complexity increase (threading)
- ‚ùå Process must stay running
- ‚ùå Memory overhead
- ‚ùå Harder to debug
- ‚ùå Thread cleanup needed
- ‚ùå Windows/Linux differences

### Recommended?
**NO** - Over-engineering for this use case

---

## üîÑ Automation Level 5: Scheduled Jobs (Cron-like)
**Complexity:** HIGH | **Time:** 2 days | **Value:** LOW

### What It Does
External scheduler (Windows Task Scheduler, cron) runs refresh commands periodically.

### Implementation

**Windows (Task Scheduler):**
```powershell
# create-scheduled-refresh.ps1
$action = New-ScheduledTaskAction -Execute "cursor" -Argument "bmad-master *context7-kb-refresh"
$trigger = New-ScheduledTaskTrigger -Daily -At 9am
Register-ScheduledTask -Action $action -Trigger $trigger -TaskName "BMAD-KB-Refresh"
```

**Linux (Cron):**
```bash
# Add to crontab
0 9 * * * cd /path/to/project && cursor bmad-master *context7-kb-refresh
```

### Changes Required
- Create OS-specific scripts
- Document setup for Windows/Linux/Mac
- Handle authentication/permissions
- Test across platforms

### Pros
- ‚úÖ True scheduled automation
- ‚úÖ Runs without user
- ‚úÖ OS-native solution

### Cons
- ‚ùå Platform-specific setup
- ‚ùå Requires external configuration
- ‚ùå Hard to debug
- ‚ùå May run when not needed
- ‚ùå Complexity of OS schedulers

### Recommended?
**NO** - Too much complexity, wrong tool for job

---

## üéØ **RECOMMENDED APPROACH**

Combine **Level 1** + **Level 2** for best results:

### **Hybrid: Smart Auto-Queue + Manual Refresh**

```python
# On agent startup (Level 1)
if os.path.exists('.refresh-queue'):
    print("üîÑ Processing 2 queued refreshes...")
    process_queue_silently()
    print("‚úÖ Done")

# On first KB access in session (Level 2)
if not SESSION_CHECKED:
    SESSION_CHECKED = True
    stale = check_all_staleness()
    if stale:
        print(f"üìã {len(stale)} libraries need refresh")
        auto_queue_all(stale)
        print(f"üí° They'll refresh on next agent startup")
```

**User Experience:**
1. ‚úÖ Stale items detected automatically
2. ‚úÖ Queued automatically
3. ‚úÖ Processed on next agent startup
4. ‚úÖ User informed but not blocked
5. ‚úÖ Can manually refresh if urgent

**Implementation Time:** 2 hours  
**Complexity:** LOW  
**Value:** HIGH  

---

## üìä Comparison Matrix

| Level | Automation | Blocking | Complexity | Time | Value | Recommended |
|-------|------------|----------|------------|------|-------|-------------|
| **Current** | None | No | Minimal | Done | Medium | ‚úÖ OK |
| **Level 1** | Startup | 2-5s | Low | 30min | Medium | ‚≠ê‚≠ê‚≠ê GOOD |
| **Level 2** | First Access | 500ms | Low | 1hr | High | ‚≠ê‚≠ê‚≠ê‚≠ê BETTER |
| **Hybrid** | Both | 2-5s once | Low | 2hr | High | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê BEST |
| **Level 3** | On Access | 2-5s | Medium | 2hr | High | ‚ö†Ô∏è MAYBE |
| **Level 4** | Background | No | High | 1day | Medium | ‚ùå NO |
| **Level 5** | Scheduled | No | High | 2days | Low | ‚ùå NO |

---

## üí° Implementation Effort Breakdown

### **Level 1: Startup Auto-Process** (30 minutes)
```python
# Add to each agent's activation (one liner)
if os.path.exists('.refresh-queue'):
    process_queue_silently()
```

**Changes:**
- Modify 9 agent activation instructions
- Add `process_queue_silently()` function
- Test startup behavior

**Risk:** LOW  
**Benefit:** MEDIUM  

---

### **Level 2: First-Access Check** (1 hour)
```python
# Add session tracking
SESSION_KB_CHECKED = False

def kb_lookup_with_auto_check(library, topic):
    global SESSION_KB_CHECKED
    
    if not SESSION_KB_CHECKED:
        SESSION_KB_CHECKED = True
        auto_check_and_queue_stale()
    
    return normal_kb_lookup(library, topic)
```

**Changes:**
- Add session tracking variable
- Modify KB lookup function
- Add auto-check-and-queue logic
- Test session behavior

**Risk:** LOW  
**Benefit:** HIGH  

---

### **Hybrid: Both** (2 hours)
Combine Level 1 + Level 2:

```python
# On startup (agent activation)
if os.path.exists('.refresh-queue'):
    process_queue_silently()

# On first KB access
if not SESSION_KB_CHECKED:
    SESSION_KB_CHECKED = True
    stale = check_all_staleness()
    if stale:
        auto_queue_all(stale)
        notify_user(stale)
```

**Changes:**
- Everything from Level 1 + Level 2
- Coordinate both systems
- Test combined behavior

**Risk:** LOW  
**Benefit:** HIGH  

---

## üö¶ Decision Guide

### **Choose Manual (Current)** If:
- ‚úÖ You want maximum control
- ‚úÖ You check KB weekly anyway
- ‚úÖ You prefer no surprises
- ‚úÖ You have a routine

### **Choose Level 1 (Startup)** If:
- ‚úÖ You want "set and forget"
- ‚úÖ You restart agents daily
- ‚úÖ You're OK with 2-5s delay on startup
- ‚úÖ You want minimal changes

### **Choose Level 2 (First Access)** If:
- ‚úÖ You want proactive notifications
- ‚úÖ You access KB frequently
- ‚úÖ You like being informed
- ‚úÖ You want auto-queuing

### **Choose Hybrid (Both)** If:
- ‚úÖ You want best of both worlds
- ‚úÖ You're OK with 2 hours implementation
- ‚úÖ You want "smart" automation
- ‚úÖ You want maximum freshness

### **Avoid Level 3+** Unless:
- ‚ùå You have very specific requirements
- ‚ùå You're willing to manage complexity
- ‚ùå You need real-time freshness
- ‚ùå You have DevOps resources

---

## üìã Hybrid Implementation Plan (Recommended)

If you want more automation, here's the **simple 2-hour plan**:

### **Part A: Startup Auto-Process** (30 min)

**File:** `.bmad-core/agents/bmad-master.md` (and 8 others)

```yaml
activation-instructions:
  - STEP 3c: Auto-process KB refresh queue
    ```python
    import os
    if os.path.exists('docs/kb/context7-cache/.refresh-queue'):
        from .tasks.context7_kb_refresh import process_queue_silently
        count = process_queue_silently()
        if count > 0:
            print(f"üîÑ Processed {count} queued KB refreshes")
    ```
```

**Function to add:**
```python
def process_queue_silently() -> int:
    """Process queue without verbose output"""
    queue = get_refresh_queue()
    if not queue:
        return 0
    
    for item in queue:
        try:
            fetch_and_cache_from_context7(item['library'], item['topic'])
            update_last_checked(item['library'])
        except Exception as e:
            # Log but don't show errors
            pass
    
    clear_refresh_queue()
    return len(queue)
```

---

### **Part B: First-Access Check** (1 hour)

**File:** `.bmad-core/tasks/context7-kb-lookup.md`

```python
# Add to top of file
_SESSION_KB_CHECKED = False

def kb_lookup_with_session_check(library, topic):
    global _SESSION_KB_CHECKED
    
    # First access in session
    if not _SESSION_KB_CHECKED:
        _SESSION_KB_CHECKED = True
        
        # Check all libraries for staleness
        stale_libs = []
        for lib in list_cached_libraries():
            if is_cache_stale(lib):
                stale_libs.append(lib)
                queue_refresh(lib, 'all')
        
        # Notify user
        if stale_libs:
            print(f"üìã Info: {len(stale_libs)} libraries need refresh")
            print(f"   Stale: {', '.join(stale_libs)}")
            print(f"üí° They'll refresh on next agent startup")
            print()
    
    # Normal lookup
    return standard_kb_lookup(library, topic)
```

---

### **Part C: Config Update** (15 min)

**File:** `.bmad-core/core-config.yaml`

```yaml
context7:
  knowledge_base:
    refresh:
      enabled: true
      auto_process_on_startup: true      # NEW: Level 1
      auto_check_on_first_access: true   # NEW: Level 2
      notify_stale: true
      # ... rest of config
```

---

### **Part D: User Notification** (15 min)

Make it clear what's happening:

```python
# On startup (if queue processed)
üîÑ Processed 2 queued KB refreshes (vitest, pytest) - 4.2s

# On first access (if stale found)
üìã Info: 2 libraries need refresh
   Stale: vitest (35d), pytest (42d)
üí° They'll refresh on next agent startup
```

---

## ‚ö° Quick Decision Tree

```
Do you want more automation?
‚îú‚îÄ NO ‚Üí Keep current (manual) ‚úÖ
‚îÇ
‚îú‚îÄ A LITTLE ‚Üí Implement Level 1 (startup) ‚≠ê‚≠ê‚≠ê
‚îÇ   ‚îî‚îÄ Time: 30 minutes
‚îÇ   ‚îî‚îÄ Risk: LOW
‚îÇ   ‚îî‚îÄ Value: MEDIUM
‚îÇ
‚îú‚îÄ MORE ‚Üí Implement Level 2 (first access) ‚≠ê‚≠ê‚≠ê‚≠ê
‚îÇ   ‚îî‚îÄ Time: 1 hour
‚îÇ   ‚îî‚îÄ Risk: LOW
‚îÇ   ‚îî‚îÄ Value: HIGH
‚îÇ
‚îú‚îÄ MAXIMUM (simple) ‚Üí Implement Hybrid ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê
‚îÇ   ‚îî‚îÄ Time: 2 hours
‚îÇ   ‚îî‚îÄ Risk: LOW
‚îÇ   ‚îî‚îÄ Value: HIGH
‚îÇ
‚îî‚îÄ FULLY AUTOMATIC ‚Üí Avoid Levels 3-5 ‚ùå
    ‚îî‚îÄ Complexity: HIGH
    ‚îî‚îÄ Time: 1-2 days
    ‚îî‚îÄ Value: Not worth it
```

---

## üéØ My Recommendation

**Implement the HYBRID approach** (Level 1 + Level 2):

### Why?
1. ‚úÖ **2 hours total** - Quick win
2. ‚úÖ **Low complexity** - No threads, no daemons
3. ‚úÖ **High value** - Queue auto-processes, stale auto-detected
4. ‚úÖ **User-friendly** - Clear notifications
5. ‚úÖ **Non-blocking** - Only 2-5s once on startup
6. ‚úÖ **Simple to debug** - Just file operations
7. ‚úÖ **Reversible** - Easy to disable if issues

### What User Sees:
```bash
# Agent startup
@bmad-master
üîÑ Processed 2 queued KB refreshes - 4.2s
üßô BMad Master Activated

# First KB access
*context7-docs vitest coverage
üìã Info: 1 library needs refresh (playwright)
üí° It'll refresh on next agent startup

üìÑ Using cached docs (verified fresh)
[documentation]
```

**Clean. Clear. Automatic enough. Not over-engineered.** ‚ú®

---

## üí∞ Cost-Benefit Analysis

### Manual (Current)
- Cost: 5 min/week user time
- Benefit: Full control
- ROI: ‚≠ê‚≠ê‚≠ê

### Level 1 (Startup)
- Cost: 30 min implementation + 2-5s startup
- Benefit: Zero user effort for queue
- ROI: ‚≠ê‚≠ê‚≠ê‚≠ê

### Level 2 (First Access)
- Cost: 1 hour implementation + 500ms first access
- Benefit: Automatic detection & queuing
- ROI: ‚≠ê‚≠ê‚≠ê‚≠ê

### Hybrid (Recommended)
- Cost: 2 hours implementation + 2-5s startup
- Benefit: Fully automatic freshness
- ROI: ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê

### Level 3+ (Over-engineered)
- Cost: 1-2 days implementation + ongoing maintenance
- Benefit: Marginal over Hybrid
- ROI: ‚≠ê (not worth it)

---

## üöÄ If You Want to Proceed

I can implement the **Hybrid approach** in about **2 hours**:

### Checklist
- [ ] Add startup queue processing (all agents)
- [ ] Add first-access checking
- [ ] Update config with automation flags
- [ ] Test startup behavior
- [ ] Test first-access behavior
- [ ] Update documentation
- [ ] Validate no breaking changes

### What You Get
- ‚úÖ Automatic queue processing on startup
- ‚úÖ Automatic staleness detection on first KB use
- ‚úÖ Auto-queuing of stale items
- ‚úÖ Clear user notifications
- ‚úÖ Non-blocking operation
- ‚úÖ Simple, debuggable code

---

## üìñ Summary

| Question | Answer |
|----------|--------|
| **What does it take?** | 30 min to 2 hours depending on level |
| **Is it worth it?** | YES for Levels 1-2, NO for Levels 3+ |
| **What's recommended?** | Hybrid (Level 1 + 2) for 2 hours |
| **What's simplest?** | Level 1 for 30 minutes |
| **Will it over-engineer?** | Levels 1-2: NO, Levels 3+: YES |

---

## üéØ The Bottom Line

**To make it "a little more automatic":**
- **Minimum:** 30 minutes (startup processing)
- **Optimal:** 2 hours (hybrid approach)
- **Maximum (recommended):** 2 hours (don't go further)

**You decide:**
1. Keep manual (current state)
2. Add startup processing (30 min)
3. Add first-access check (1 hour)
4. Add both - hybrid (2 hours) ‚≠ê RECOMMENDED

**Want me to implement the Hybrid approach?** It's the sweet spot! üéØ

