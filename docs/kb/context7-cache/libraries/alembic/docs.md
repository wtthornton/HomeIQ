# Alembic - Database Migrations for SQLAlchemy

**Library**: Alembic
**Context7 ID**: /sqlalchemy/alembic
**Purpose**: Database migration tool for SQLAlchemy
**Last Updated**: 2025-10-19

## Overview

Alembic is a lightweight database migration tool for use with the SQLAlchemy Database Toolkit for Python. It provides a way to perform schema changes on your database in a structured and version-controlled manner.

## Key Features

- **Autogenerate**: Automatically generate migration scripts by comparing database schema with SQLAlchemy models
- **Version Control**: Track database schema changes with revision control
- **Upgrade/Downgrade**: Migrate forward or backward between revisions
- **Branching**: Support for multiple migration branches
- **SQL Generation**: Generate SQL scripts without executing them

## Installation

```bash
pip install alembic
```

## Core Concepts

### 1. Migration Revision Files

Migration files contain `upgrade()` and `downgrade()` functions:

```python
"""Add user email column

Revision ID: 27c6a30d7c24
Revises: None
Create Date: 2011-11-08 11:40:27.089406
"""

# revision identifiers
revision = '27c6a30d7c24'
down_revision = None

from alembic import op
import sqlalchemy as sa

def upgrade():
    op.add_column('user', sa.Column('email', sa.String(255)))

def downgrade():
    op.drop_column('user', 'email')
```

### 2. Autogenerate Migrations

```bash
# Create new migration with autogenerate
alembic revision --autogenerate -m "add user table"

# Review and edit the generated file before applying
```

### 3. Applying Migrations

```bash
# Upgrade to latest version
alembic upgrade head

# Upgrade to specific revision
alembic upgrade ae1027a6acf

# Downgrade one revision
alembic downgrade -1

# Downgrade to specific revision
alembic downgrade 1975ea83b712

# Downgrade to base (empty database)
alembic downgrade base
```

## Python API Usage

### Creating and Running Migrations

```python
from alembic import command
from alembic.config import Config

config = Config("alembic.ini")

# Create new migration with autogenerate
command.revision(
    config,
    message="add user table",
    autogenerate=True,
    head="head"
)

# Create manual migration
command.revision(
    config,
    message="custom changes",
    autogenerate=False
)

# Upgrade to latest version
command.upgrade(config, "head")

# Upgrade to specific revision
command.upgrade(config, "ae1027a6acf")

# Downgrade operations
command.downgrade(config, "-1")
command.downgrade(config, "1975ea83b712")
command.downgrade(config, "base")
```

### Generating SQL Scripts

```python
from alembic import command
from alembic.config import Config

config = Config("alembic.ini")

# Generate SQL for upgrade (without executing)
command.upgrade(config, "head", sql=True)

# Generate SQL for specific range
command.upgrade(config, "base:head", sql=True)

# Generate SQL for downgrade
command.downgrade(config, "base:ae1027a6acf", sql=True)
```

### Checking for Pending Migrations

```python
from alembic import command
from alembic.config import Config
from alembic.util import CommandError
from alembic.util.exc import AutogenerateDiffsDetected

config = Config("alembic.ini")

try:
    # Check will raise exception if differences detected
    command.check(config)
    print("No pending migrations")
except AutogenerateDiffsDetected as e:
    print(f"Pending migrations detected: {e}")
    print(f"Diffs: {e.diffs}")
except CommandError as e:
    print(f"Error: {e}")
```

## Common Operations

### Add Column

```python
from alembic import op
import sqlalchemy as sa

def upgrade():
    op.add_column('user', sa.Column('email', sa.String(255)))

def downgrade():
    op.drop_column('user', 'email')
```

### Create Table

```python
def upgrade():
    op.create_table(
        'account',
        sa.Column('id', sa.Integer(), nullable=False),
        sa.Column('name', sa.String(50), nullable=False),
        sa.Column('description', sa.VARCHAR(200)),
        sa.Column('last_transaction_date', sa.DateTime()),
        sa.PrimaryKeyConstraint('id')
    )

def downgrade():
    op.drop_table('account')
```

### Batch Migrations (SQLite)

For SQLite which doesn't support many ALTER operations:

```python
def upgrade():
    with op.batch_alter_table('address', schema=None) as batch_op:
        batch_op.add_column(sa.Column('street', sa.String(50), nullable=True))

def downgrade():
    with op.batch_alter_table('address', schema=None) as batch_op:
        batch_op.drop_column('street')
```

## Best Practices

1. **Always Review Autogenerated Migrations**: Autogenerate is smart but not perfect. Review and edit generated files.

2. **Test Migrations**: Test both upgrade and downgrade paths in development before applying to production.

3. **Use Descriptive Messages**: Make migration messages clear and descriptive.

4. **Version Control**: Commit migration files to your version control system.

5. **Data Migrations**: For complex data transformations, write explicit data migration code.

6. **Environment Configuration**: Use `env.py` to configure Alembic for different environments.

## Integration with FastAPI/SQLAlchemy

```python
# alembic/env.py
from logging.config import fileConfig
from sqlalchemy import engine_from_config
from sqlalchemy import pool
from alembic import context

# Import your Base and models
from app.database import Base
from app.models import User, Device, Entity  # Import all models

# Set target metadata
target_metadata = Base.metadata

def run_migrations_online():
    """Run migrations in 'online' mode."""
    connectable = engine_from_config(
        config.get_section(config.config_ini_section),
        prefix="sqlalchemy.",
        poolclass=pool.NullPool,
    )

    with connectable.connect() as connection:
        context.configure(
            connection=connection,
            target_metadata=target_metadata
        )

        with context.begin_transaction():
            context.run_migrations()
```

## Async SQLAlchemy Support

For async SQLAlchemy (SQLAlchemy 2.0+):

```python
# alembic/env.py
from sqlalchemy.ext.asyncio import create_async_engine
import asyncio

async def run_migrations_online():
    """Run migrations in 'online' mode with async engine."""
    connectable = create_async_engine(
        config.get_section(config.config_ini_section)["sqlalchemy.url"],
    )

    async with connectable.connect() as connection:
        await connection.run_sync(do_run_migrations)

    await connectable.dispose()

def do_run_migrations(connection):
    context.configure(
        connection=connection,
        target_metadata=target_metadata
    )

    with context.begin_transaction():
        context.run_migrations()

asyncio.run(run_migrations_online())
```

## Resources

- Official Documentation: https://alembic.sqlalchemy.org/
- Tutorial: https://alembic.sqlalchemy.org/en/latest/tutorial.html
- Auto-generation: https://alembic.sqlalchemy.org/en/latest/autogenerate.html
- Cookbook: https://alembic.sqlalchemy.org/en/latest/cookbook.html

