# Vitest Documentation Cache

## Overview
Vitest is a fast, Vite-native testing framework with Jest compatibility. This cache contains focused documentation on testing, mocking, and coverage.

## Test Framework Setup

### Configuration
- **vitest.config.ts**: Test configuration file
- **Test environment**: Node.js and browser environments
- **TypeScript support**: Native TypeScript testing
- **ESM support**: Native ES modules
- **Watch mode**: Automatic test re-running
- **Parallel execution**: Concurrent test execution

### Test Structure
- **Test files**: Organizing test suites
- **Test functions**: Individual test cases
- **Test suites**: Grouping related tests
- **Setup and teardown**: Test lifecycle management
- **Test isolation**: Independent test execution
- **Test discovery**: Automatic test finding

### Assertions
- **Built-in matchers**: Jest-compatible assertions
- **Custom matchers**: Extending assertion library
- **Async assertions**: Testing async code
- **Snapshot testing**: UI regression testing
- **Error assertions**: Testing error conditions
- **Type assertions**: TypeScript type checking

## Mocking Capabilities

### Mock Functions
- **vi.fn()**: Creating mock functions
- **vi.spyOn()**: Spying on existing functions
- **vi.mock()**: Module mocking
- **Mock implementations**: Custom mock behavior
- **Mock return values**: Controlling mock responses
- **Mock calls**: Verifying mock invocations

### Module Mocking
- **ESM mocking**: ES module mocking
- **Partial mocking**: Selective module mocking
- **Auto-mocking**: Automatic mock generation
- **Mock factories**: Dynamic mock creation
- **Mock hoisting**: Mock declaration hoisting
- **Mock restoration**: Mock cleanup

### Advanced Mocking
- **Timer mocking**: Date and timer mocking
- **Network mocking**: HTTP request mocking
- **File system mocking**: File system operations
- **Environment mocking**: Environment variable mocking
- **Global mocking**: Global object mocking
- **Plugin mocking**: Plugin system mocking

## Coverage Reporting

### Coverage Configuration
- **Coverage providers**: Coverage collection engines
- **Coverage thresholds**: Coverage requirements
- **Coverage reporters**: Output format configuration
- **Coverage exclusions**: Excluding files from coverage
- **Coverage instrumentation**: Code instrumentation
- **Coverage reports**: HTML and text reports

### Coverage Analysis
- **Line coverage**: Statement coverage analysis
- **Branch coverage**: Decision coverage analysis
- **Function coverage**: Function call coverage
- **Statement coverage**: Statement execution coverage
- **Coverage gaps**: Identifying untested code
- **Coverage trends**: Coverage change tracking

### Coverage Optimization
- **Selective coverage**: Targeted coverage collection
- **Coverage filtering**: Filtering coverage data
- **Coverage merging**: Combining coverage reports
- **Coverage visualization**: Coverage data visualization
- **Coverage badges**: Coverage status indicators
- **Coverage CI**: Continuous integration coverage

## TypeScript Integration

### TypeScript Support
- **Native TypeScript**: Built-in TypeScript support
- **Type checking**: TypeScript error detection
- **Type imports**: Import type syntax
- **Generic testing**: Testing generic functions
- **Interface testing**: Testing interface implementations
- **Type assertions**: TypeScript type assertions

### TypeScript Configuration
- **tsconfig.json**: TypeScript configuration
- **Type definitions**: Test type definitions
- **Type coverage**: TypeScript coverage analysis
- **Type checking**: Runtime type validation
- **Type mocking**: Mocking with types
- **Type safety**: Type-safe testing patterns

## Component Testing

### React Testing
- **React component testing**: Testing React components
- **Hook testing**: Testing custom hooks
- **Context testing**: Testing React contexts
- **Event testing**: Testing user interactions
- **State testing**: Testing component state
- **Props testing**: Testing component props

### Testing Utilities
- **Testing library**: Component testing utilities
- **User events**: Simulating user interactions
- **Query methods**: Finding elements in components
- **Async testing**: Testing async component behavior
- **Error boundaries**: Testing error handling
- **Portal testing**: Testing portal components

## Performance Testing

### Performance Metrics
- **Test execution time**: Measuring test performance
- **Memory usage**: Monitoring memory consumption
- **CPU usage**: Tracking CPU utilization
- **Bundle size**: Analyzing bundle impact
- **Startup time**: Measuring framework startup
- **Build time**: Tracking build performance

### Performance Optimization
- **Parallel execution**: Concurrent test running
- **Test isolation**: Minimizing test dependencies
- **Mock optimization**: Efficient mocking strategies
- **Coverage optimization**: Selective coverage collection
- **Resource management**: Efficient resource usage
- **Cache optimization**: Test result caching

## Best Practices
- **Test organization**: Logical test structure
- **Mock strategy**: Effective mocking patterns
- **Coverage targets**: Appropriate coverage goals
- **Performance**: Efficient test execution
- **Maintainability**: Sustainable test practices
- **Debugging**: Effective test debugging
